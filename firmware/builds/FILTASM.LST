C:\C2XXTI\DSPA.EXE -glsw -v2xx FILTASM.ASM FILTASM.obj 

TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE    1

       1            ; Filename: Filtasm.asm
       2            ;
       3            ; This C2xx assembly source file contains code for the filter module.
       4            ; It performs...
       5            ; 
       6            ; History:
       7            ;                       10/3/97 Started coding orignial - Michael Spencer
       8            
       9            ;----- Define Program Constants --------------------------------------------
      10            ;junkMAX_FILT_ORDER     .set    24      ; Maximum filter order of each channel (even)
      11            
      12            ; Include useful constants for the TMS320C203 assembly language
      13                            .include        "C203.inc"
      14            
      15            ;----- Define program variable locations -----------------------------------
      16            ; Variable starting with _ and defined .global can be accessed from c-code
      17            
      18 0000       temp            .usect  "bank2",1
      19 0001       temp2           .usect  "bank2",1
      20 0002       randnum         .usect  "bank2",1       ; random number register
      21            ;_in_new_a      .usect  "bank2",1       ; define CODEC I/O words
      22 0003       _in_a           .usect  "bank2",1
      23                                    .global  _in_a
      24 0004       _in_b           .usect  "bank2",1
      25                                    .global  _in_b
      26 0005       _in_error       .usect  "bank2",1
      27                                    .global  _in_error
      28 0006       _in_error_stick .usect  "bank2",1 ; version of in_error where bits are only set, not cleared
      29                                    .global  _in_error_stick
      30 0007       _in_digital     .usect  "bank2",1
      31                                    .global _in_digital
      32 0008       _out_a          .usect  "bank2",1
      33                                    .global _out_a
      34 0009       _out_old_a      .usect  "bank2",1       ; must be after _out_a (because of dmov instruction)
      35 000a       _out_b          .usect  "bank2",1
      36                                    .global  _out_b
      37 000b       _out_gain       .usect  "bank2",1
      38                                    .global  _out_gain
      39 000c       _out_atten      .usect  "bank2",1
      40                                    .global  _out_atten
      41 000d       _in_a_hold      .usect  "bank2",1       ; used to hold the peak values for the VU Meter
      42                                    .global _in_a_hold
      43 000e       _in_b_hold      .usect  "bank2",1       ; used to hold the peak values for the VU Meter
      44                                    .global _in_b_hold
      45 000f       _out_a_hold     .usect  "bank2",1       ; used to hold the peak values for the VU Meter
      46                                    .global _out_a_hold
      47 0010       _out_b_hold     .usect  "bank2",1       ; used to hold the peak values for the VU Meter
      48                                    .global _out_b_hold
      49 0011       _t_reg_scale_a  .usect  "bank2",1       ; used to scale ch a data after filter
      50                                    .global  _t_reg_scale_a
      51 0012       _t_reg_scale_b  .usect  "bank2",1       ; used to scale ch b data after filter
      52                                    .global  _t_reg_scale_b
      53 0013       _func_addr_a  .usect    "bank2",1       ; used to point to address of current function A
      54                                    .global  _func_addr_a
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE    2

      55 0014       _func_addr_b  .usect    "bank2",1       ; used to point to address of current function B
      56                                    .global  _func_addr_b
      57 0015       _assembly_flag  .usect  "bank2",1       ; used to flag the assembly code from C code:
      58                                    .global  _assembly_flag ; bit position  function
      59                                                                                    ; 15 (LSB)              Flags VU Meter p
      60                                                                                    ; 13                    Flags cascade Ch
      61                                                                                    ; 12                    Flags the white 
      62            
      63 0016       _coef_ptr_a  .usect     "bank2",1       ; used to point to starting address of filter A coefs (changed in c-code
      64                                    .global  _coef_ptr_a
      65 0017       _coef_ptr_b  .usect     "bank2",1       ; used to point to starting address of filter B coefs (changed in c-code
      66                                    .global  _coef_ptr_b
      67 0018       _data_ptr_a .usect      "bank2",1       ; used to point to starting address of ch a filter data
      68                                    .global  _data_ptr_a
      69 0019       _data_ptr_b .usect      "bank2",1       ; used to point to starting address of ch b filter data
      70                                    .global  _data_ptr_b
      71 001a       _orderm2_a      .usect  "bank2",1       ; used to hold FIR filter A order minus 2
      72                                    .global  _orderm2_a
      73 001b       _orderm2_b      .usect  "bank2",1       ; used to hold FIR filter B order minus 2
      74                                    .global  _orderm2_b
      75 001c       _iosr_copy      .usect  "bank2",1       ; used to hold a copy of the IO status register (txrxint interrups)
      76                                    .global  _iosr_copy
      77            
      78 001d       _k7f00h         .usect  "bank2",1       ; define memory for costants (for speed)
      79                                    .global  _k7f00h        ; value assigned in c-code
      80 001e       _kf80fh         .usect  "bank2",1       ; define memory for costants (for speed)
      81                                    .global  _kf80fh        ; value assigned in c-code
      82 001f       _kfff0h         .usect  "bank2",1       ; define memory for costants (for speed)
      83                                    .global  _kfff0h        ; value assigned in c-code
      84            
      85            
      86            ; Reserve FIR filter coeficient storage for two channels in internal DATA memory.
      87            ; FIR: Two filters up to 128 taps each are stored or one long filter up to 256 taps
      88            ; Memory bank B0 is placed into program space by setting CNF bit.
      89            ;   Channel A   -       up to 128 tap weights (or up to 256 tap weights for one filter)
      90            ;   Channel B   -       up to 128 tap weights
      91            
      92 0000       _fir_coef       .usect  "bank0",256
      93                                    .global _fir_coef       ; declare it as external so c-code can write values
      94            
      95            ; Reserve FIR state data and IIR coeficient and state data for two channels in
      96            ; internal DATA memory.
      97            ; Ch A ocupies 380-3ff (or 300-3ff for one long filter)
      98            ; Ch B ocupies 300-37f
      99            ; For FIR: An Nth order filter requires N data locations
     100            ; For IIR: Each second order section requires 3 state locations.
     101            ;                  Each second order section requires 5 coeficients.
     102 0000       _coefdata       .usect  "bank1",256
     103                                    .global _coefdata       ; declare as external so c-code can write state
     104            
     105            
     106            ;***** Define Interrupt Vector Table ***************************************
     107 0000                       .sect   "vectors"
     108            ;start: b       _c_int0         ; branch to C-Code entry point on reset
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE    3

     109 0000 7980  start:  b       _boot2          ; on reset: branch to our custom boot routine to load sector 2 of FLSAH
         0001 0005' 
     110 0002 7980  int1:   b       start       ; restart ; install interrupt vector for external int1 pin
         0003 0000+ 
     111 0004 7980  int2:   b       start       ; restart
         0005 0000+ 
     112 0006 7980  tint:   b       start       ; restart
         0007 0000+ 
     113 0008 7980  rint:   b       rint_asm        ; install interrupt vector for serial receive (CODEC)
         0009 00cd' 
     114            ;               b       _rint_c         ; install interrupt vector for serial receive (CODEC)
     115            ;               .global _rint_c
     116 000a 7980  xint:   b       start       ; restart
         000b 0000+ 
     117 000c 7980  txrxint: b      txrxint_asm     ; install interrupt vector for asynchronous serial port & IO pins
         000d 0086' 
     118            ;               .global _txrxint_c
     119 000e 7980                  b       start       ; restart
         000f 0000+ 
     120 0010 7980  int8:   b       start       ; restart
         0011 0000+ 
     121 0012 7980  int9:   b       start       ; restart
         0013 0000+ 
     122 0014 7980  int10:  b       start       ; restart
         0015 0000+ 
     123 0016 7980  int11:  b       start       ; restart
         0017 0000+ 
     124 0018 7980  int12:  b       start       ; restart
         0019 0000+ 
     125 001a 7980  int13:  b       start       ; restart
         001b 0000+ 
     126 001c 7980  int14:  b       start       ; restart
         001d 0000+ 
     127 001e 7980  int15:  b       start       ; restart
         001f 0000+ 
     128 0020 7980  int16:  b       start       ; restart
         0021 0000+ 
     129 0022 7980  trap:   b       start       ; restart
         0023 0000+ 
     130 0024 7980  nmi:    b       start       ; restart
         0025 0000+ 
     131 0026 7980                  b       start       ; restart
         0027 0000+ 
     132 0028 7980  int20:  b       start       ; restart
         0029 0000+ 
     133 002a 7980  int21:  b       start       ; restart
         002b 0000+ 
     134 002c 7980  int22:  b       start       ; restart
         002d 0000+ 
     135 002e 7980  int23:  b       start       ; restart
         002f 0000+ 
     136 0030 7980  int24:  b       start       ; restart
         0031 0000+ 
     137 0032 7980  int25:  b       start       ; restart
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE    4

         0033 0000+ 
     138 0034 7980  int26:  b       start       ; restart
         0035 0000+ 
     139 0036 7980  int27:  b       start       ; restart
         0037 0000+ 
     140 0038 7980  int28:  b       start       ; restart
         0039 0000+ 
     141 003a 7980  int29:  b       start       ; restart
         003b 0000+ 
     142 003c 7980  int30:  b       start       ; restart
         003d 0000+ 
     143 003e 7980  int31:  b       start       ; restart
         003f 0000+ 
     144            
     145            
     146 0000                       .text                   ; put following into begining of code section
     147 0000       serial_no:
     148 0000 3939                  .string "9999997768"    ; The SN is the first 6 digits, followed by
         0001 3939  
         0002 3939  
         0003 3737  
         0004 3638  
     149                                                                            ; 4 check sum digits: ######oess
     150                                                                            ; This SN resides from 40h to 49h
     151            ;               .string "Copyrighted 1997-1998, Signal Processing Solutions"
     152            ;===========================================================================
     153            ;  BEGIN ASSEMBLLY FUNCTIONS AND SUBROUTINE DEFINITIONS.
     154            ;  Functions starting with a "_" can be called by C code.
     155            ;===========================================================================
     156            
     157                            .global _boot2  ; called by c (during testing only)
     158 0005       _boot2:
     159            ;**********************************************************************
     160            ; This function boots the code stored in sector 2 (or 6 if knob is pressed)
     161            ; to code memory locations 3f7e-543f inclusive.
     162            ;
     163            ;**********************************************************************
     164                            ; Init:
     165 0005 bc00                  ldp             #0                      ; set data pointer to page 0
     166 0006 ae00-                 splk    #2e00h,temp     ; set ARP=1, OVM=1, INTM=1, DP=0
         0007 2e00  
     167 0008 0e00-                 lst             #0,temp
     168 0009 ae00-                 splk    #21fch,temp     ; set ARB=1, CNF=0, SXM=0, XF=1, PM=0
         000a 21fc  
     169 000b 0f00-                 lst             #1,temp
     170 000c ae05                  splk    #80h,GREG       ; GREG <- 80h, Designates locations 8000-ffffh as global
         000d 0080  
     171            
     172                            ; Raise the CLIP pins to map in FLASH sector 2(6):
     173 000e ae00-                 splk    #4300h,temp     ; put sync serial port into reset
         000f 4300  
     174 0010 0c00-                 out             temp, 0fff1h ; write the SSPCR (sync. serial port control reg.)
         0011 fff1  
     175 0012 ae00-                 splk    #4330h,temp     ; take sync serial port out of reset
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE    5

         0013 4330  
     176 0014 0c00-                 out             temp, 0fff1h ; write the SSPCR (sync. serial port control reg.)
         0015 fff1  
     177            
     178 0016 ae00-                 splk    #000ch,temp ; load temp with CODEC code for rasing CLIP pins
         0017 000c  
     179 0018 bf83                  lacc    #1000h,3        ; ACC <- 1000h
         0019 1000  
     180 001a 0c00- w_loop: out     temp, 0fff0h    ; write to the SDTR (sync. serial port data reg.)
         001b fff0  
     181                                                                    ; This causes the continuous transmision of ones untill
     182 001c ba01                  sub             #1                      ; ACC <- ACC - 1
     183 001d e304                  bcnd    w_loop,GT       ; loop till ACC <= 0
         001e 001a' 
     184            
     185                            ; Set pointers and addresses:                                                                   
     186                            ; Important: 40h        <=> code origin in the linker command file: Filtlink.cmd
     187                            ;                        5000h  <=> code length in the linker command file: Filtlink.cmd
     188 001f bf09                  lar             ar1,#8000h      ; ar1 <- first source address in FLASH
         0020 8000  
     189 0021 ae03-                 splk    #(8192+8064-2),_in_a    ; _in_a <- destination address in code memory
         0022 3f7e  
     190 0023 bf08                  lar             ar0,#(40h + 5000h - (8192+8064-2) - 1)  ; ar1 <- length of data to be transfered
         0024 10c1  
     191            
     192                            ; Transfer code:
     193 0025       boot_loop:
     194 0025 0c00-                 out     temp, 0fff0h    ; keep CLIP high by writing to the SDTR (sync. serial port data reg.)
         0026 fff0  
     195 0027 18a0                  lacc    *+,8            ; ACC <- high byte of code shifted by 8 bits
     196 0028 9004-                 sacl    _in_b           ; store high byte
     197 0029 69a8                  lacl    *+,AR0          ; ACC <- low byte of code
     198 002a bfb0                  and             #0ffh           ; mask off upper 24 bits
         002b 00ff  
     199 002c 6d04-                 or              _in_b           ; OR ACC with high byte to form 16-bit code word
     200 002d 9008-                 sacl    _out_a          ; _out_a <- code word
     201 002e 6903-                 lacl    _in_a           ; load destination address
     202 002f a708-                 tblw    _out_a          ; transfer code to destination address
     203 0030 b801                  add             #1                      ; inc. destination address
     204 0031 9003-                 sacl    _in_a           ; save destination address
     205 0032 7b99                  banz    boot_loop,*-,ar1        ; branch if not end of code
         0033 0025' 
     206            
     207 0034 ae05                  splk    #0,GREG         ; disable global memory
         0035 0000  
     208 0036 7980                  b               _c_int0         ; branch to c initialization code section
         0037 0000! 
     209                            .global _c_int0
     210            
     211            
     212                            .global _get_serial     ; function called by c
     213 0038       _get_serial:
     214            ;**********************************************************************
     215            ; This function puts the serial number string (the string at label-serial_no:)
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE    6

     216            ; and a terminating null into the 11 element character array: serial_str[]
     217            ; when called by c-code with:
     218            ;
     219            ;          get_serial(&serial_str);
     220            ;
     221            ; fix: we can shrink this code by looping over the blpd command.
     222            ;**********************************************************************
     223 0038 8aa0                  popd    *+                      ; pop return address, push on c-stack
     224 0039 80a0                  sar             ar0,*+          ; push c Frame Pointer
     225 003a 8180                  sar             ar1,*           ; push c Stack Pointer
     226 003b b001                  lar             ar0,#1h         ; size of Frame
     227 003c 00ea                  lar             ar0,*0+,ar2     ; set up FP and SP
     228                            
     229 003d bc00-                 ldp             #temp           ; Load data pointer to page 0
     230 003e be46                  clrc    sxm                     ; clear sign extension mode
     231                            
     232 003f bf0a                  lar             ar2,#0fffdh
         0040 fffd  
     233 0041 8be0                  mar             *0+
     234                            
     235 0042 038b                  lar             ar3,*,ar3
     236 0043 a500-                 blpd    #serial_no,temp ; put first word of serial number into temp
         0044 0000' 
     237 0045 1800-                 lacc    temp, 8         ; put high byte into ACC high
     238 0046 988a                  sach    *,0,ar2         ; save
     239 0047 038b                  lar             ar3,*,ar3
     240 0048 7801                  adrk    #1h
     241 0049 6a00-                 lacc    temp, 16        ; put into ACC high
     242 004a be81                  and             #00ffh,16       ; mask of high byte
         004b 00ff  
     243 004c 988a                  sach    *,0,ar2         ; save
     244            
     245 004d 038b                  lar             ar3,*,ar3
     246 004e 7802                  adrk    #2h
     247 004f a500-                 blpd    #(serial_no+1),temp ; put first word of serial number into temp
         0050 0001' 
     248 0051 1800-                 lacc    temp, 8         ; put high byte into ACC high
     249 0052 988a                  sach    *,0,ar2         ; save
     250 0053 038b                  lar             ar3,*,ar3
     251 0054 7803                  adrk    #3h
     252 0055 6a00-                 lacc    temp, 16        ; put into ACC high
     253 0056 be81                  and             #00ffh,16       ; mask of high byte
         0057 00ff  
     254 0058 988a                  sach    *,0,ar2         ; save
     255            
     256 0059 038b                  lar             ar3,*,ar3
     257 005a 7804                  adrk    #4h
     258 005b a500-                 blpd    #(serial_no+2),temp ; put first word of serial number into temp
         005c 0002' 
     259 005d 1800-                 lacc    temp, 8         ; put high byte into ACC high
     260 005e 988a                  sach    *,0,ar2         ; save
     261 005f 038b                  lar             ar3,*,ar3
     262 0060 7805                  adrk    #5h
     263 0061 6a00-                 lacc    temp, 16        ; put into ACC high
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE    7

     264 0062 be81                  and             #00ffh,16       ; mask of high byte
         0063 00ff  
     265 0064 988a                  sach    *,0,ar2         ; save
     266            
     267 0065 038b                  lar             ar3,*,ar3
     268 0066 7806                  adrk    #6h
     269 0067 a500-                 blpd    #(serial_no+3),temp ; put first word of serial number into temp
         0068 0003' 
     270 0069 1800-                 lacc    temp, 8         ; put high byte into ACC high
     271 006a 988a                  sach    *,0,ar2         ; save
     272 006b 038b                  lar             ar3,*,ar3
     273 006c 7807                  adrk    #7h
     274 006d 6a00-                 lacc    temp, 16        ; put into ACC high
     275 006e be81                  and             #00ffh,16       ; mask of high byte
         006f 00ff  
     276 0070 988a                  sach    *,0,ar2         ; save
     277            
     278 0071 038b                  lar             ar3,*,ar3
     279 0072 7808                  adrk    #8h
     280 0073 a500-                 blpd    #(serial_no+4),temp ; put first word of serial number into temp
         0074 0004' 
     281 0075 1800-                 lacc    temp, 8         ; put high byte into ACC high
     282 0076 988a                  sach    *,0,ar2         ; save
     283 0077 038b                  lar             ar3,*,ar3
     284 0078 7809                  adrk    #9h
     285 0079 6a00-                 lacc    temp, 16        ; put into ACC high
     286 007a be81                  and             #00ffh,16       ; mask of high byte
         007b 00ff  
     287 007c 988a                  sach    *,0,ar2         ; save
     288            
     289 007d 038b                  lar             ar3,*,ar3
     290 007e 780a                  adrk    #0ah
     291 007f b900                  lacl    #0                      ; 0 -> ACC, put the null character into ACC
     292 0080 988a                  sach    *,0,ar2         ; save
     293            
     294 0081 8b89                  larp    ar1
     295 0082 7c02                  sbrk    #2h                     ; deallocate Frame
     296 0083 0090                  lar             ar0,*-          ; pop Frame Pointer             
     297 0084 7680                  pshd    *                       ; push return address on hardware stack
     298 0085 ef00                  ret                                     ; return
     299            
     300            
     301 0086       txrxint_asm:
     302            ;**********************************************************************
     303            ; Interrupt routine is for servicing delta IO and RS-232 async. serial port
     304            ; interrupts.
     305            ;
     306            ; This ISR calls the c-functions: txrxint_c
     307            ;
     308            ; Registers destroyed: None, this is an ISR!
     309            ; 
     310            ;**********************************************************************
     311                            .global _txrxint_c
     312            
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE    8

     313            ; save all registers on c stack (except the hardware stack):
     314 0086 8b89                  MAR             *, AR1  ; CURRENT ARP = C-STACK POINTER
     315 0087 7801                  ADRK    #1h             ; SKIP TOP ELEMENT ON STACK
     316 0088 8fa0                  SST             #1,*+   ; SAVE STATUS REGISTERS
     317 0089 8ea0                  SST             #0,*+
     318            
     319 008a 8aa0                  POPD    *+              ; pop the return address, push on c-stack
     320                                                            ; This is nessary to avoid hardware stack overflow since this
     321                                                            ; ISR can be interuppted by itself.
     322 008b 8aa0                  POPD    *+
     323 008c 8aa0                  POPD    *+
     324 008d 8aa0                  POPD    *+
     325 008e 8aa0                  POPD    *+
     326 008f 8aa0                  POPD    *+
     327 0090 8aa0                  POPD    *+
     328 0091 8aa0                  POPD    *+
     329                            
     330            
     331 0092 bc00-         ldp             #temp                   ; Load data pointer to page 0
     332            
     333            ;       splk    #0080h,temp             ; Signal the entry into body of txrxint_asm
     334            ;       out             temp, 0                 ; by setting module pin28 (this causes a display crash if this I
     335            ;       splk    #8,temp
     336            ;       out             temp,IOSR               ; Set IO3 bit to signal the entry into ISR (I think this is trou
     337            
     338 0093 af1c-         in              _iosr_copy,IOSR ; Get copy of IOSR
         0094 fff6  
     339            ;       out             _kfff0h,IOSR    ; Reset any bits that could have caused the interrupt
     340 0095 ae04          splk    #0008h, IMR             ; Mask TXRXINT interrupt so this ISR is not re-interrupted
         0096 0008  
     341            ;       splk    #CLR_TXRXINT, IFR       ; Clear TXRXINT flag in IFR to avoid double ints
     342 0097 be40          clrc    INTM                    ; Re-enable interrupts so we don't miss a sample int.
     343                    
     344            
     345 0098 98a0                  SACH    *+      ; SAVE ACCUMULATOR
     346 0099 90a0                  SACL    *+
     347            
     348            ;               CLRC    OVM             ; TURN OFF OVERFLOW MODE (never modified by c-code, p. 4-10)
     349            ;               SPM             0               ; PRODUCT SHIFT COUNT OF 0 (never modified by c-code, p. 4-10)
     350            
     351 009a 8da0          SPH      *+             ; SAVE P REGISTER (assmues PM = 0)
     352 009b 8ca0          SPL      *+
     353            
     354 009c c001                  MPY             #1h             ; SAVE T REGISTER 
     355 009d 8ca0                  SPL             *+
     356            
     357 009e 80a0                  SAR             AR0,*+  ; SAVE AUXILIARY REGISTERS
     358 009f 82a0                  SAR             AR2,*+
     359 00a0 83a0                  SAR             AR3,*+
     360 00a1 84a0                  SAR             AR4,*+
     361 00a2 85a0                  SAR             AR5,*+
     362 00a3 86a0                  SAR             AR6,*+
     363 00a4 87a9                  SAR             AR7,*+,AR1
     364                            
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE    9

     365            ; body...
     366            
     367 00a5 8b89                  mar             *,AR1           ; Prepare for the C-function call
     368 00a6 7a80                  call    _txrxint_c      ; Call c-code to get the switch or RS-232 action and put into FIFO
         00a7 0000! 
     369            
     370            ;               ldp             #temp           ; Load data pointer to page 0
     371            ;               splk    #0028h, IMR     ; Unmask TXRXINT interrupt so that the next switch action is not missed
     372            
     373            ; restore registers and return
     374 00a8 8b89                  MAR             *, AR1
     375 00a9 8b90                  MAR             *-
     376 00aa 0790                  LAR             AR7,*-  ; RESTORE AUX REGISTERS
     377 00ab 0690                  LAR             AR6,*-
     378 00ac 0590                  LAR             AR5,*-
     379 00ad 0490                  LAR             AR4,*-
     380 00ae 0390                  LAR             AR3,*-
     381 00af 0290                  LAR             AR2,*-
     382 00b0 0090                  LAR             AR0,*-
     383            
     384 00b1 8b90                  MAR     *-      ; SKIP T REGISTER (FOR NOW)
     385 00b2 73a0                  LT      *+              
     386 00b3 c001                  MPY             #1h     ; RESTORE LOW PRODUCT REGISTER
     387                            
     388 00b4 7390                  LT      *-      ; RESTORE T REGISTER
     389 00b5 8b90                  MAR     *-      ; SKIP LOW PRODUCT REGISTER VALUE
     390 00b6 7590                  LPH     *-      ; RESTORE HIGH PRODUCT REGISTER
     391            
     392 00b7 6990                  LACL    *-      ; RESTORE ACCUMULATOR
     393 00b8 6190                  ADD             *-,16
     394            
     395 00b9 bc00-         ldp             #temp                   ; Load data pointer to page 0
     396            ;       splk    #00f0h,temp
     397            ;       out             temp,IOSR               ; Reset delta bits in case of switch bounce
     398            ;       out             _kfff0h,IOSR    ; Reset delta bits in case of switch bounce
     399            
     400 00ba 0c1f-         out             _kfff0h,IOSR    ; Reset any bits that could have caused the interrupt or since the int.
         00bb fff6  
     401 00bc ae06          splk    #CLR_TXRXINT, IFR       ; Clear TXRXINT flag in IFR to avoid double ints
         00bd 0020  
     402            
     403            
     404            ;       splk    #0000h,temp             ; fix: Signal the exit from body of txrxint_asm
     405            ;       out             temp, 0                 ; by clearing module pin28
     406            ;       splk    #0,temp
     407            ;       out             temp,IOSR               ; Clear IO3 bit to signal exit from ISR
     408            
     409 00be be41          setc    INTM                    ; Disable interrupts so we can guarantee a return before another
     410                                                                    ; txrxint interrupt (avoids a hardware stack overflow).
     411 00bf ae04          splk    #0028h, IMR             ; Unmask TXRXINT interrupt for next time
         00c0 0028  
     412            
     413 00c1 7690                  PSHD    *-              ; push return address on hardware stack
     414 00c2 7690                  PSHD    *-              ; push return address on hardware stack
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   10

     415 00c3 7690                  PSHD    *-              ; push return address on hardware stack
     416 00c4 7690                  PSHD    *-              ; push return address on hardware stack
     417 00c5 7690                  PSHD    *-              ; push return address on hardware stack
     418 00c6 7690                  PSHD    *-              ; push return address on hardware stack
     419 00c7 7690                  PSHD    *-              ; push return address on hardware stack
     420 00c8 7690                  PSHD    *-              ; push return address on hardware stack
     421            
     422 00c9 0e90                  LST             #0,*-   ; RESTORE STATUS REGISTERS
     423 00ca 0f90                  LST             #1,*-   ; OLD ARP IS RESTORED *NOW*
     424            
     425 00cb be40          clrc    INTM    ; Enable interrupts
     426 00cc ef00                  ret                             ; return from interrupt
     427            
     428            
     429            ;               .global  _rint_asm      ; declare as global for c to call
     430 00cd       rint_asm:
     431            ;**********************************************************************
     432            ; Interrupt service routine for receive interrupt. It services the
     433            ; CODEC by reading and writing 4 words in the synchronus serial port
     434            ; FIFOs.
     435            ;
     436            ; Registers destroyed: None, this is an ISR!
     437            ; 
     438            ;**********************************************************************
     439            
     440            ; save all modified registers on c stack:
     441 00cd 8b89                  MAR             *, AR1  ; CURRENT ARP = STACK POINTER
     442 00ce 7801                  ADRK    #1h             ; SKIP TOP ELEMENT ON STACK
     443 00cf 8fa0                  SST             #1,*+   ; SAVE STATUS REGISTERS
     444 00d0 8ea0                  SST             #0,*+
     445            
     446 00d1 bc00-         ldp             #temp           ; Load data pointer to page 0
     447 00d2 af04-         in              _in_b,SDTR      ; Read in sample from ch b of CODEC             Frame n
         00d3 fff0  
     448 00d4 0c0b-         out             _out_gain,SDTR  ; Write gain word out
         00d5 fff0  
     449            
     450            ;       splk    #8,temp
     451            ;       out             temp,IOSR       ; Fix: Set IO3 bit to signal the entry into body of rint_asm
     452                                                            ; Note this screws up read_flash() and write_flash() in c
     453                    
     454 00d6 98a0                  SACH    *+      ; SAVE ACCUMULATOR
     455 00d7 90a0                  SACL    *+
     456            
     457            ;               clrc    OVM             ; TURN OFF OVERFLOW MODE (never modified by c-code, p. 4-10)
     458            ;               SPM             0               ; PRODUCT SHIFT COUNT OF 0 (never modified by c-code, p. 4-10)
     459            
     460 00d8 8da0          SPH             *+              ; SAVE P REGISTER (assmues PM = 0)
     461 00d9 8ca0          SPL             *+
     462            
     463 00da c001                  MPY             #1h             ; SAVE T REGISTER 
     464 00db 8ca0                  SPL             *+
     465            
     466 00dc 80a0                  SAR             AR0,*+ ; SAVE AUXILIARY REGISTERS 0 and 2
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   11

     467 00dd 828a                  SAR             AR2,*,AR2
     468            
     469                            
     470            ; body...
     471            
     472            ; Read and Write CODEC registers:
     473 00de af05-                 in              _in_error,SDTR  ; Read in error word from CODEC
         00df fff0  
     474 00e0 0c09-                 out             _out_old_a,SDTR ; Write out ch a sample to CODEC                Frame
         00e1 fff0  
     475 00e2 7708-                 dmov    _out_a                  ; Delay Ch A output by one sample: _out_a -> _out_old_a
     476 00e3 af03-                 in              _in_a,SDTR              ; Read in sample from ch b of CODEC             Frame
         00e4 fff0  
     477 00e5 0c0c-                 out             _out_atten,SDTR ; Write attenuation word out
         00e6 fff0  
     478            
     479            ; Check for shift error in received word:
     480 00e7 691e-                 lacl    _kf80fh                 ; load masking constant from memory (for speed)
     481 00e8 6e05-                 and             _in_error
     482 00e9 ba08                  sub             #8                              ; ACC <- ACC - 8
     483 00ea e308                  bcnd    skip, NEQ               ; skip last I/O if there was a receive error
         00eb 0134' 
     484            
     485            ;               nop             ; need 2-NOPs here to delay for 8KHz ch. B !!!
     486            ;               nop
     487            
     488 00ec be47                  setc    sxm             ; set sign extension mode, requred for random number gen. and _notch fun
     489 00ed be43                  setc    ovm     ; set overflow mode to hard limit accumulations
     490            
     491 00ee 4c15-                 bit             _assembly_flag, 12      ; white noise bit -> TC
     492 00ef e200                  bcnd    rand_skip,NTC           ; skip cascade hold if flag not set
         00f0 00fb' 
     493            ; Random number generator (see Numerical Recipies p. 284 to learn this is not the way to do a rand gen.):
     494 00f1 7302-         lt              randnum
     495 00f2 c035          mpy             #53             ; 53
     496 00f3 be03          pac                     ; load ACC with PREG
     497 00f4 bf90          add             #15473  ; 15473
         00f5 3c71  
     498 00f6 9002-         sacl    randnum
     499 00f7 1002-         lacc    randnum ; 16 bit data -> ACC with sign extention (assumes sxm is set)
     500 00f8 be0a          sfr                             ; ACC/2 -> ACC (to reduce the amplitude of the noise)
     501 00f9 9003-         sacl    _in_a
     502 00fa 9004-         sacl    _in_b
     503 00fb       rand_skip:        
     504            
     505 00fb af07-                 in              _in_digital,SDTR ; Read digital input word of CODEC
         00fc fff0  
     506 00fd 0c0a-                 out             _out_b,SDTR             ; Write out ch b sample to CODEC                Frame
         00fe fff0  
     507            
     508            ; Set any bits in in_error_stick so we can turn on the CLIP LEDs in c-code:
     509 00ff 6906-                 lacl    _in_error_stick ; put sticky error code into ACC
     510 0100 6d05-                 or              _in_error               ; logical OR with current error code to set any bits
     511 0101 9006-                 sacl    _in_error_stick ; save new sticky error code
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   12

     512            
     513            ; Call to _func_addr_a:
     514 0102 6913-                 lacl    _func_addr_a    ; get the current A function address ...
     515 0103 be30                  cala                                    ; and call it
     516            
     517            
     518 0104 4f15-                 bit             _assembly_flag, 15      ; vu_flag -> TC
     519 0105 e200                  bcnd    rint_out_b,NTC  ; skip peak hold if flag not set
         0106 0123' 
     520            ;               b       rint_out_b
     521            ; Hold peak values for VU Meter functionality in c-code (overflow mode (ovm) must be set):
     522 0107 6a03-                 lacc    _in_a,16                ; load ACC with data
     523 0108 be00                  abs                                             ; |data| -> ACC
     524 0109 650d-                 sub             _in_a_hold,16   ; ACC - hold -> ACC
     525 010a e3cc                  bcnd    rint_in_a,LEQ   ; branch if this sample is not a maximum
         010b 010e' 
     526 010c 610d-                 add             _in_a_hold,16   ; recalulate: |data| -> ACC
     527 010d 980d-                 sach    _in_a_hold              ; save new maximum
     528 010e       rint_in_a:
     529            
     530 010e 6a04-                 lacc    _in_b,16                ; load ACC with data
     531 010f be00                  abs                                             ; |data| -> ACC
     532 0110 650e-                 sub             _in_b_hold,16   ; ACC - hold -> ACC
     533 0111 e3cc                  bcnd    rint_in_b,LEQ   ; branch if this sample is not a maximum
         0112 0115' 
     534 0113 610e-                 add             _in_b_hold,16   ; recalulate: |data| -> ACC
     535 0114 980e-                 sach    _in_b_hold              ; save new maximum
     536 0115       rint_in_b:
     537            
     538 0115 6a08-                 lacc    _out_a,16               ; load ACC with data
     539 0116 be00                  abs                                             ; |data| -> ACC
     540 0117 650f-                 sub             _out_a_hold,16  ; ACC - hold -> ACC
     541 0118 e3cc                  bcnd    rint_out_a,LEQ  ; branch if this sample is not a maximum
         0119 011c' 
     542 011a 610f-                 add             _out_a_hold,16  ; recalulate: |data| -> ACC
     543 011b 980f-                 sach    _out_a_hold             ; save new maximum
     544 011c       rint_out_a:
     545            
     546 011c 6a0a-                 lacc    _out_b,16               ; load ACC with data
     547 011d be00                  abs                                             ; |data| -> ACC
     548 011e 6510-                 sub             _out_b_hold,16  ; ACC - hold -> ACC
     549 011f e3cc                  bcnd    rint_out_b,LEQ  ; branch if this sample is not a maximum
         0120 0123' 
     550 0121 6110-                 add             _out_b_hold,16  ; recalulate: |data| -> ACC
     551 0122 9810-                 sach    _out_b_hold             ; save new maximum
     552 0123       rint_out_b:
     553            
     554            
     555            ; Scale _out_a, _out_b and hard limit (clip):
     556            ; (_t_reg_scale_x/256) * _out_x -> _out_x
     557 0123 bf01                  spm             1                               ; set product mode (PM) to 1 (if not)
     558            
     559 0124 7311-                 lt              _t_reg_scale_a  ; _t_reg_scale_a -> T
     560 0125 5408-                 mpy             _out_a                  ; _out_x x T -> P
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   13

     561 0126 be03                  pac                                             ; 2 * P -> ACC
     562            ; Largest pos# in ACC = 0000 000[0 1111 1111 1111 111]X XXXX XXXX, []=_out_x
     563            ; Hard limit ACC if there was a positive or negative overflow:
     564 0127 611d-                 add             _k7f00h,16
     565 0128 651d-                 sub             _k7f00h,16
     566 0129 651d-                 sub             _k7f00h,16
     567 012a 611d-                 add             _k7f00h,16
     568 012b 9f08-                 sach    _out_a, 7               ; int[ACC x 2^(7-16)] -> _out_b
     569            
     570 012c 7312-                 lt              _t_reg_scale_b  ; _t_reg_scale_b -> T
     571 012d 540a-                 mpy             _out_b                  ; _out_x x T -> P
     572 012e be03                  pac                                             ; 2 * P -> ACC
     573            ; Largest pos# in ACC = 0000 000[0 1111 1111 1111 111]X XXXX XXXX, []=_out_x
     574            ; Hard limit ACC if there was a positive or negative overflow:
     575 012f 611d-                 add             _k7f00h,16
     576 0130 651d-                 sub             _k7f00h,16
     577 0131 651d-                 sub             _k7f00h,16
     578 0132 611d-                 add             _k7f00h,16
     579 0133 9f0a-                 sach    _out_b, 7               ; int[ACC x 2^(7-16)] -> _out_b
     580                            
     581            ;        rpt            #10             ; waste time
     582            ;        nop
     583                    
     584 0134       skip:
     585 0134 ae06                  splk    #CLR_RINT, IFR  ; Clear receive interrupt flag in IFR to avoid double ints
         0135 0008  
     586            
     587            ;               clrc    ovm             ; TURN OFF OVERFLOW MODE (must be 0 for c-code, p. 4-10)
     588                                                            ; this is restored with ST0 below !
     589                                                            
     590            ; restore registers and return
     591 0136 8b89                  MAR             *, AR1
     592 0137 0290                  LAR             AR2,*-  ; RESTORE AUX REGISTERS 0 and 2
     593 0138 0090                  LAR             AR0,*-
     594            
     595 0139 8b90                  MAR     *-      ; SKIP T REGISTER (FOR NOW)
     596 013a 73a0                  LT      *+              
     597 013b c001                  MPY             #1h     ; RESTORE LOW PRODUCT REGISTER
     598                            
     599 013c 7390                  LT      *-      ; RESTORE T REGISTER
     600 013d 8b90                  MAR     *-      ; SKIP LOW PRODUCT REGISTER VALUE
     601 013e 7590                  LPH     *-      ; RESTORE HIGH PRODUCT REGISTER
     602            
     603 013f 6990                  LACL    *-      ; RESTORE ACCUMULATOR
     604 0140 6190                  ADD             *-,16
     605            
     606            ;       splk    #0,temp
     607            ;       out             temp,IOSR       ; fix: Clear IO3 bit to signal exit from body of rint_asm
     608            
     609 0141 0e90                  LST             #0,*-   ; RESTORE STATUS REGISTERS
     610 0142 0f90                  LST             #1,*-   ; OLD ARP IS RESTORED *NOW*
     611 0143 be40                  clrc    INTM ; Enable interrupts
     612 0144 ef00                  ret                     ; return from interrupt
     613             
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   14

     614            
     615            ;**********************************************************************
     616            ; no functions for A and B:
     617            ; 
     618            ;**********************************************************************
     619                            .global _no_func_a      ; declare function as global so c-code can find it
     620 0145       _no_func_a: 
     621 0145 ae08-                 splk    #0h,_out_a      ; output zero value
         0146 0000  
     622            
     623            ; End of Ch A
     624 0147 6914-                 lacl    _func_addr_b    ; get the current B function address ...
     625 0148 be20                  bacc                                    ; and branch to it
     626            
     627            ;**********************************************************************
     628                            .global _no_func_b      ; declare function as global so c-code can find it
     629 0149       _no_func_b: 
     630 0149 ae0a-                 splk    #0h,_out_b      ; output zero value
         014a 0000  
     631 014b ef00                  ret
     632            
     633            ;**********************************************************************
     634            ; allpass functions for A and B:
     635            ; 
     636            ;**********************************************************************
     637                            .global _allpass_func_a ; declare function as global so c-code can find it
     638 014c       _allpass_func_a:
     639 014c 6903-                 lacl    _in_a                   ; in -> ACC
     640 014d 9008-                 sacl    _out_a                  ; ACC low -> out
     641            ; End of Ch A
     642 014e 6914-                 lacl    _func_addr_b    ; get the current B function address ...
     643 014f be20                  bacc                                    ; and branch to it
     644            
     645            ;**********************************************************************
     646                            .global _allpass_func_b ; declare function as global so c-code can find it
     647 0150       _allpass_func_b:
     648            ; Start of Ch B
     649 0150 6904-                 lacl    _in_b                   ; in -> ACC
     650 0151 4d15-                 bit             _assembly_flag, 13      ; cascade_flag -> TC
     651 0152 e200                  bcnd    allpass_skip,NTC        ; skip cascade hold if flag not set
         0153 0155' 
     652 0154 6908-                 lacl    _out_a                  ; Ch A output -> ACC
     653 0155       allpass_skip:
     654 0155 900a-                 sacl    _out_b                  ; ACC low -> out
     655 0156 ef00                  ret
     656            
     657            
     658            ;**********************************************************************
     659            ; FIR Filter functions for Ch A and B
     660            ; Use different function for different max impulse response value:
     661            ;                                               fir_15_a        - Channel A, s1=15, s2=0, PM=1
     662            ;                                               fir_15_b        - Channel B, s1=15, s2=0, PM=1
     663            ;
     664            ;                                               fir_16_a        - Channel A, s1=16, s2=0, PM=0
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   15

     665            ;                                               fir_16_b        - Channel B, s1=16, s2=0, PM=0
     666            ;
     667            ; C-code sets the following values:
     668            ;
     669            ;       _func_addr_a    =       address of function A to call
     670            ;       _func_addr_b    =       address of function B to call
     671            ;       _orderm2_a              =       N - 2, N = 3 to 128 for 2 or to 256 for ch A filter only
     672            ;       _orderm2_b              =       N - 2, N = 3 to 128 for both filters
     673            ;       _data_ptr_a     =       0x03ff-N+1, (points to first address filter data ch a: d0)
     674            ;       _data_ptr_b     =       0x037f-N+1, (points to first address filter data ch b: d0)
     675            ;
     676            ;               _data_ptr_b:    d0              - ch b
     677            ;                                               d1 ...
     678            ;               0x037f:                 d(N-1)
     679            ;
     680            ;               _data_ptr_a:    d0              - ch a
     681            ;                                               d1 ...
     682            ;               0x03ff:                 d(N-1)
     683            ;
     684            ;       _fir_coef[] = array of coeficient data:                 fir_coef[0] = h(N-1) - ch a
     685            ;               Clear CNF bit to write fir_coef[]                       fir_coef[1] = h(N-2)
     686            ;               Then set CNF bit to map to prog memory.         ...
     687            ;               (_fir_coef is in B0: 200-2ff)                           fir_coef[N-1] = h(0)
     688            ;
     689            ;                                                                                                       fir_coef
     690            ;                                                                                                       fir_coef
     691            ;                                                                                                       ...
     692            ;                                                                                                       fir_coef
     693            ;
     694            ; Coeficent values are stored = int or round[(2^s1)*true_coef_value]
     695            ;
     696            ; For optimum scaling use different functions for different maximum
     697            ; impulse response values as follows:
     698            ; coef scaling shift: s1 = 16 - s2 - PM
     699            ; output shift:           s2 = 16 - s1 + PM
     700            ; Valid combinations (assuming truncation of scaled ideal coefs):
     701            ;                       max(h)                  use:    s1      s2      PM      function
     702            ;               [0.5       to 1)                        15      0       1       _fir_15_x
     703            ;               [0         to 0.5)                      16      0       0       _fir_16_x
     704            ;
     705            ;               [0.015625  to 0.03125)          _fir_20_x (not used)
     706            ;               [0.0078125 to 0.015625)         _fir_21_x (not used)
     707            ;               [0         to 0.0078125)        _fir_22_x (not used)
     708            ;                                               
     709            ;**********************************************************************
     710                            .global _fir_15_a       ; declare function as global so c-code can find it
     711 0157       _fir_15_a:      ; Ch A FIR filter, s1 = 15
     712 0157 bf01                  spm             1                               ; set product mode (PM) to 1
     713 0158 8b8a                  mar             *,AR2                   ; AR2 -> ARP
     714            
     715 0159 6903-                 lacl    _in_a                   ; in -> ACC
     716 015a 0218-                 lar             AR2, _data_ptr_a ; point to state data location d0
     717 015b 9088                  sacl    *,AR0           ; ACC -> d0
     718 015c bf08                  lar             AR0, #03ffh             ; point to first state data addr used -> AR0
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   16

         015d 03ff  
     719             
     720 015e b900                  lacl    #0                              ; 0 -> ACC
     721 015f c000                  mpy             #0                              ; 0 -> P
     722 0160 a290                  mac             0ff00h,*-               ; ACC + shifted(P) -> ACC
         0161 ff00  
     723                                                                            ; d(N-1) -> T
     724                                                                            ; d(N-1) * coef(N-1) -> P
     725 0162 0b1a-                 rpt             _orderm2_a              ; i = 2 to N (_orderm2 = N - 2)
     726 0163 a390                  macd    0ff01h, *-              ; ACC + shifted(P) -> ACC
         0164 ff01  
     727                                                                            ; d(N-i) -> T
     728                                                                            ; d(N-i) * coef(N-i) -> P
     729                                                                            ; d(N-i) -> d(N-i+1)
     730 0165 be04                  apac                                    ; ACC + shifted(P) -> ACC
     731 0166 9808-                 sach    _out_a,0                ; shifted(ACC) -> out (shift by s2)
     732            
     733            ; End of Ch A
     734 0167 6914-                 lacl    _func_addr_b    ; get the current B function address ...
     735 0168 be20                  bacc                                    ; and branch to it
     736            
     737            ;**********************************************************************
     738                            .global _fir_15_b       ; declare function as global so c-code can find it
     739 0169       _fir_15_b:      ; Ch B FIR filter, s1 = 15
     740 0169 bf01                  spm             1                               ; set product mode (PM) to 1
     741 016a 8b8a                  mar             *,AR2                   ; AR2 -> ARP
     742                            
     743 016b 6904-                 lacl    _in_b                   ; in -> ACC
     744 016c 4d15-                 bit             _assembly_flag, 13      ; cascade_flag -> TC
     745 016d e200                  bcnd    fir_15_skip,NTC ; skip cascade hold if flag not set
         016e 0170' 
     746 016f 6908-                 lacl    _out_a                  ; Ch A output -> ACC
     747 0170       fir_15_skip:
     748            
     749 0170 0219-                 lar             AR2, _data_ptr_b ; point to state data location d0
     750 0171 9088                  sacl    *,AR0           ; ACC -> d0
     751 0172 bf08                  lar             AR0, #037fh             ; point to first state data addr used -> AR0
         0173 037f  
     752            
     753 0174 b900                  lacl    #0                              ; 0 -> ACC
     754 0175 c000                  mpy             #0                              ; 0 -> P
     755 0176 a290                  mac             0ff80h,*-               ; ACC + shifted(P) -> ACC
         0177 ff80  
     756                                                                            ; d(N-1) -> T
     757                                                                            ; d(N-1) * coef(N-1) -> P
     758 0178 0b1b-                 rpt             _orderm2_b              ; i = 2 to N (_orderm2 = N - 2)
     759 0179 a390                  macd    0ff81h, *-              ; ACC + shifted(P) -> ACC
         017a ff81  
     760                                                                            ; d(N-i) -> T
     761                                                                            ; d(N-i) * coef(N-i) -> P
     762                                                                            ; d(N-i) -> d(N-i+1)
     763 017b be04                  apac                                    ; ACC + shifted(P) -> ACC
     764 017c 980a-                 sach    _out_b,0                ; shifted(ACC) -> out (shift by s2)
     765 017d ef00                  ret
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   17

     766                            
     767            ;**********************************************************************
     768                            .global _fir_16_a       ; declare function as global so c-code can find it
     769 017e       _fir_16_a:      ; Ch A FIR filter, s1 = 15
     770 017e bf00                  spm             0                               ; clear product mode (PM) to 0
     771 017f 8b8a                  mar             *,AR2                   ; AR2 -> ARP
     772            
     773 0180 6903-                 lacl    _in_a                   ; in -> ACC
     774 0181 0218-                 lar             AR2, _data_ptr_a ; point to state data location d0
     775 0182 9088                  sacl    *,AR0           ; ACC -> d0
     776 0183 bf08                  lar             AR0, #03ffh             ; point to first state data addr used -> AR0
         0184 03ff  
     777             
     778 0185 b900                  lacl    #0                              ; 0 -> ACC
     779 0186 c000                  mpy             #0                              ; 0 -> P
     780 0187 a290                  mac             0ff00h,*-               ; ACC + shifted(P) -> ACC
         0188 ff00  
     781                                                                            ; d(N-1) -> T
     782                                                                            ; d(N-1) * coef(N-1) -> P
     783 0189 0b1a-                 rpt             _orderm2_a              ; i = 2 to N (_orderm2 = N - 2)
     784 018a a390                  macd    0ff01h, *-              ; ACC + shifted(P) -> ACC
         018b ff01  
     785                                                                            ; d(N-i) -> T
     786                                                                            ; d(N-i) * coef(N-i) -> P
     787                                                                            ; d(N-i) -> d(N-i+1)
     788 018c be04                  apac                                    ; ACC + shifted(P) -> ACC
     789            ;       lacc    _in_a, 16
     790 018d 9808-                 sach    _out_a,0                ; shifted(ACC) -> out (shift by s2)
     791            
     792            ; End of Ch A
     793 018e 6914-                 lacl    _func_addr_b    ; get the current B function address ...
     794 018f be20                  bacc                                    ; and branch to it
     795            
     796            ;**********************************************************************
     797                            .global _fir_16_b       ; declare function as global so c-code can find it
     798 0190       _fir_16_b:      ; Ch B FIR filter, s1 = 15
     799 0190 bf00                  spm             0                               ; clear product mode (PM) to 0
     800 0191 8b8a                  mar             *,AR2                   ; AR2 -> ARP
     801                            
     802 0192 6904-                 lacl    _in_b                   ; in -> ACC
     803 0193 4d15-                 bit             _assembly_flag, 13      ; cascade_flag -> TC
     804 0194 e200                  bcnd    fir_16_skip,NTC ; skip cascade hold if flag not set
         0195 0197' 
     805 0196 6908-                 lacl    _out_a                  ; Ch A output -> ACC
     806 0197       fir_16_skip:
     807            
     808 0197 0219-                 lar             AR2, _data_ptr_b ; point to state data location d0
     809 0198 9088                  sacl    *,AR0           ; ACC -> d0
     810 0199 bf08                  lar             AR0, #037fh             ; point to first state data addr used -> AR0
         019a 037f  
     811            
     812 019b b900                  lacl    #0                              ; 0 -> ACC
     813 019c c000                  mpy             #0                              ; 0 -> P
     814 019d a290                  mac             0ff80h,*-               ; ACC + shifted(P) -> ACC
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   18

         019e ff80  
     815                                                                            ; d(N-1) -> T
     816                                                                            ; d(N-1) * coef(N-1) -> P
     817 019f 0b1b-                 rpt             _orderm2_b              ; i = 2 to N (_orderm2 = N - 2)
     818 01a0 a390                  macd    0ff81h, *-              ; ACC + shifted(P) -> ACC
         01a1 ff81  
     819                                                                            ; d(N-i) -> T
     820                                                                            ; d(N-i) * coef(N-i) -> P
     821                                                                            ; d(N-i) -> d(N-i+1)
     822 01a2 be04                  apac                                    ; ACC + shifted(P) -> ACC
     823            ;       lacc    _in_b, 16
     824 01a3 980a-                 sach    _out_b,0                ; shifted(ACC) -> out (shift by s2)
     825 01a4 ef00                  ret
     826                            
     827            
     828            ;**********************************************************************
     829            ; Notch, Inverse Notch, and Equalizer Filter functions:
     830            ;                                               notch_a         - Channel A, 2nd order notch
     831            ;                                               notch_b         - Channel B, 2nd order notch
     832            ;
     833            ; The notch filter is realized as the weighted sum of a 2nd order
     834            ; lattice allpass filter and the input (see IEEE Procedings, Jan. 1998, p. 29).
     835            ;
     836            ; C-code sets the following values:
     837            ;
     838            ;       _func_addr_a    =       address of Ch A function
     839            ;       _func_addr_b    =       address of Ch B function
     840            ;
     841            ;       _coef_ptr_b             =       points to first filter coeficient  Ch B (in B1: 300h):
     842            ;       _data_ptr_b             =       points to first used state address Ch B (in B1: 37fh)
     843            ;       _coef_ptr_a             =       points to first filter coeficient  Ch A (in B1: 380h):
     844            ;       _data_ptr_a             =       points to first used state address Ch A (in B1: 3ffh)
     845            ;
     846            ; 300h  _coef_ptr_b:    c(2)    - Ch B, section 2
     847            ;                                               k(2)
     848            ;                                               d(2)
     849            ;                                               k(2) (copy)
     850            ;                                               c(1)    - Ch B, section 1
     851            ;                                               k(1)
     852            ;                                               d(1)
     853            ;                                               k(1) (copy)
     854            ;                                               g(1)
     855            ;                                               g(2)
     856            ;
     857            ;                                               ... (coef and data grow towards each other)
     858            ;                                               state(1)        - Ch B, section 1
     859            ;                                               state(2)        - Ch B, section 2
     860            ; 37fh  _data_ptr_b:    state(3)        - Ch B, memory location for allpass output
     861            ;
     862            ;
     863            ; 380h  _coef_ptr_a:    c(2)    - Ch A, section 2
     864            ;                                               k(2)
     865            ;                                               d(2)
     866            ;                                               k(2) (copy)
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   19

     867            ;                                               c(1)    - Ch A, section 1
     868            ;                                               k(1)
     869            ;                                               d(1)
     870            ;                                               k(1) (copy)
     871            ;                                               g(1)
     872            ;                                               g(2)
     873            ;
     874            ;                                               ... (coef and data grow towards each other)
     875            ;                                               state(1)        - Ch A, section 1
     876            ;                                               state(2)        - Ch A, section 2
     877            ; 3ffh  _data_ptr_a:    state(3)        - Ch A, memory location for allpass output
     878            ;
     879            ;
     880            ; Coeficent values are stored = int[(2^15)*true_coef_value]
     881            ;                                                         =     int[32768*true_coef_value]
     882            ;
     883            ;**********************************************************************
     884                            .global _notch_a        ; declare function as global so c-code can find it
     885 01a5       _notch_a:       ; Ch A, 2nd order notch filter:
     886            
     887 01a5 bf01                  spm             1                       ; set product mode (PM) to 1
     888 01a6 0216-                 lar             AR2, _coef_ptr_a ; point to first coef address
     889 01a7 0018-                 lar             AR0, _data_ptr_a ; point to state data location N+1
     890 01a8 8b8a                  mar             *,AR2           ; AR2 -> ARP (point to coefs)
     891                            
     892 01a9 1f03-                 lacc    _in_a,15        ; _in_a/2 -> temp2(_out_a)
     893 01aa 9808-                 sach    _out_a
     894            
     895            ;       clrc    ovm             ; fix: clear overflow mode to see overflows better
     896            
     897                    ; Section N=2:
     898                    ; Forward:              
     899 01ab b900                  lacl    #0                      ; 0 -> ACC
     900 01ac 7308-                 lt              _out_a          ; temp2(_out_a) -> T
     901 01ad 54a8                  mpy             *+,AR0          ; T*c2 -> P
     902 01ae 7c01                  sbrk    1                       ; AR0-1 -> AR0 (point to state2)
     903 01af 73aa                  lt              *+,AR2          ; state2 -> T
     904 01b0 50a0                  mpya    *+                      ; ACC+P -> ACC, T*k2 -> P
     905 01b1 be05                  spac                            ; ACC-P -> ACC
     906 01b2 9800-                 sach    temp            ; ACC -> temp
     907                    ; Backward:
     908 01b3 b900                  lacl    #0                      ; 0 -> ACC
     909 01b4 54a0                  mpy             *+                      ; T*d2 -> P
     910 01b5 7308-                 lt              _out_a          ; temp2(_out_a) -> T
     911 01b6 50a8                  mpya    *+,AR0          ; ACC+P -> ACC, T*k2 -> P
     912 01b7 be04                  apac                            ; ACC+P -> ACC
     913 01b8 999a                  sach    *-,1,AR2        ; 2*ACC -> state3
     914            
     915                    ; Section N-1=1:
     916                    ; Forward:              
     917 01b9 b900                  lacl    #0                      ; 0 -> ACC
     918 01ba 7300-                 lt              temp            ; temp -> T
     919 01bb 54a8                  mpy             *+,AR0          ; T*c1 -> P
     920 01bc 7c01                  sbrk    1                       ; AR0-1 -> AR0 (point to state1)
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   20

     921 01bd 73aa                  lt              *+,AR2          ; state1 -> T
     922 01be 50a0                  mpya    *+                      ; ACC+P -> ACC, T*k1 -> P
     923 01bf be05                  spac                            ; ACC-P -> ACC
     924 01c0 9808-                 sach    _out_a          ; ACC -> temp2(_out_a)
     925                    ; Backward:
     926 01c1 b900                  lacl    #0                      ; 0 -> ACC
     927 01c2 54a0                  mpy             *+                      ; T*d1 -> P
     928 01c3 7300-                 lt              temp            ; temp -> T
     929 01c4 50a8                  mpya    *+,AR0          ; ACC+P -> ACC, T*k1 -> P
     930 01c5 be04                  apac                            ; ACC+P -> ACC
     931 01c6 9890                  sach    *-                      ; ACC -> state2
     932            
     933                    ; Feedback:
     934 01c7 6908-                 lacl    _out_a          ; temp2(_out_a) -> ACC
     935 01c8 9080                  sacl    *                       ; ACC -> state1
     936            
     937                    ; Weighted sum of allpass part and input:
     938 01c9 bf02                  spm             2                       ; set product mode (PM) to 2
     939 01ca 7802                  adrk    2                       ; AR0+2 -> AR0 (point to state3)
     940            
     941 01cb 1003-                 lacc    _in_a           ; _in_a -> ACC
     942 01cc 2080                  add             *,0                     ; ACC+state3(allpas output) -> ACC
     943 01cd be0a                  sfr                                     ; ACC/2 -> ACC
     944 01ce 9000-                 sacl    temp            ; ACC -> temp
     945            
     946 01cf 1003-                 lacc    _in_a           ; _in_a -> ACC
     947 01d0 308a                  sub             *,0,AR2         ; ACC-state3(allpas output) -> ACC
     948 01d1 be0a                  sfr                                     ; ACC/2 -> ACC
     949 01d2 9008-                 sacl    _out_a          ; ACC -> _out_a
     950                            
     951 01d3 b900                  lacl    #0                      ; 0 -> ACC
     952 01d4 7300-                 lt              temp            ; temp -> T
     953 01d5 54a0                  mpy             *+                      ; T*g1 -> P
     954 01d6 7308-                 lt              _out_a          ; _out_a -> T
     955 01d7 50a0                  mpya    *+                      ; ACC+P -> ACC, T*g2 -> P
     956 01d8 be04                  apac                            ; ACC+P -> ACC
     957 01d9 9808-                 sach    _out_a          ; ACC -> out
     958            
     959            
     960            ; End of Ch A
     961 01da 6914-                 lacl    _func_addr_b    ; get the current B function address ...
     962 01db be20                  bacc                                    ; and branch to it
     963            
     964            ;**********************************************************************
     965                            .global _notch_b        ; declare function as global so c-code can find it
     966 01dc       _notch_b:       ; Ch B, 2nd order notch filter:
     967            
     968            ; Start of Ch B
     969 01dc 6904-                 lacl    _in_b           ; _in_b/2 -> ACC
     970 01dd 4d15-                 bit             _assembly_flag, 13      ; cascade_flag -> TC
     971 01de e200                  bcnd    notch_skip,NTC  ; skip cascade hold if flag not set
         01df 01e1' 
     972 01e0 6908-                 lacl    _out_a          ; _out_a/2 -> ACC
     973 01e1       notch_skip:
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   21

     974 01e1 9001-                 sacl    temp2           ; ACC -> temp2 (input)
     975            
     976 01e2 1f01-                 lacc    temp2,15        ; input/2 -> temp2(_out_b)
     977 01e3 980a-                 sach    _out_b
     978            
     979 01e4 bf01                  spm             1                       ; set product mode (PM) to 1
     980 01e5 0217-                 lar             AR2, _coef_ptr_b ; point to first coef address
     981 01e6 0019-                 lar             AR0, _data_ptr_b ; point to state data location N+1
     982 01e7 8b8a                  mar             *,AR2           ; AR2 -> ARP (point to coefs)
     983            
     984            ;       clrc    ovm             ; fix: clear overflow mode to see overflows better
     985                            
     986                    ; Section N=2:
     987                    ; Forward:              
     988 01e8 b900                  lacl    #0                      ; 0 -> ACC
     989 01e9 730a-                 lt              _out_b          ; temp3(_out_b) -> T
     990 01ea 54a8                  mpy             *+,AR0          ; T*c2 -> P
     991 01eb 7c01                  sbrk    1                       ; AR0-1 -> AR0 (point to state2)
     992 01ec 73aa                  lt              *+,AR2          ; state2 -> T
     993 01ed 50a0                  mpya    *+                      ; ACC+P -> ACC, T*k2 -> P
     994 01ee be05                  spac                            ; ACC-P -> ACC
     995 01ef 9800-                 sach    temp            ; ACC -> temp
     996                    ; Backward:
     997 01f0 b900                  lacl    #0                      ; 0 -> ACC
     998 01f1 54a0                  mpy             *+                      ; T*d2 -> P
     999 01f2 730a-                 lt              _out_b          ; temp3(_out_b) -> T
    1000 01f3 50a8                  mpya    *+,AR0          ; ACC+P -> ACC, T*k2 -> P
    1001 01f4 be04                  apac                            ; ACC+P -> ACC
    1002 01f5 999a                  sach    *-,1,AR2        ; 2*ACC -> state3
    1003            
    1004                    ; Section N-1=1:
    1005                    ; Forward:              
    1006 01f6 b900                  lacl    #0                      ; 0 -> ACC
    1007 01f7 7300-                 lt              temp            ; temp -> T
    1008 01f8 54a8                  mpy             *+,AR0          ; T*c1 -> P
    1009 01f9 7c01                  sbrk    1                       ; AR0-1 -> AR0 (point to state1)
    1010 01fa 73aa                  lt              *+,AR2          ; state1 -> T
    1011 01fb 50a0                  mpya    *+                      ; ACC+P -> ACC, T*k1 -> P
    1012 01fc be05                  spac                            ; ACC-P -> ACC
    1013 01fd 980a-                 sach    _out_b          ; ACC -> temp2(_out_b)
    1014                    ; Backward:
    1015 01fe b900                  lacl    #0                      ; 0 -> ACC
    1016 01ff 54a0                  mpy             *+                      ; T*d1 -> P
    1017 0200 7300-                 lt              temp            ; temp -> T
    1018 0201 50a8                  mpya    *+,AR0          ; ACC+P -> ACC, T*k1 -> P
    1019 0202 be04                  apac                            ; ACC+P -> ACC
    1020 0203 9890                  sach    *-                      ; ACC -> state2
    1021            
    1022                    ; Feedback:
    1023 0204 690a-                 lacl    _out_b          ; temp2(_out_b) -> ACC
    1024 0205 9080                  sacl    *                       ; ACC -> state1
    1025            
    1026                    ; Weighted sum of allpass part and input:
    1027 0206 bf02                  spm             2                       ; set product mode (PM) to 2
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   22

    1028 0207 7802                  adrk    2                       ; AR0+2 -> AR0 (point to state3)
    1029                            
    1030 0208 1001-                 lacc    temp2           ; temp2 -> ACC
    1031 0209 2080                  add             *,0                     ; ACC+state3(allpas output) -> ACC
    1032 020a be0a                  sfr                                     ; ACC/2 -> ACC
    1033 020b 9000-                 sacl    temp            ; ACC -> temp
    1034            
    1035 020c 1001-                 lacc    temp2           ; temp2 -> ACC
    1036 020d 308a                  sub             *,0,AR2         ; ACC-state3(allpas output) -> ACC
    1037 020e be0a                  sfr                                     ; ACC/2 -> ACC
    1038 020f 900a-                 sacl    _out_b          ; ACC -> _out_b
    1039                            
    1040 0210 b900                  lacl    #0                      ; 0 -> ACC
    1041 0211 7300-                 lt              temp            ; temp -> T
    1042 0212 54a0                  mpy             *+                      ; T*g1 -> P
    1043 0213 730a-                 lt              _out_b          ; _out_b -> T
    1044 0214 50a0                  mpya    *+                      ; ACC+P -> ACC, T*g2 -> P
    1045 0215 be04                  apac                            ; ACC+P -> ACC
    1046 0216 980a-                 sach    _out_b          ; ACC -> out
    1047            
    1048 0217 ef00                  ret
    1049                            
    1050            
    1051            
    1052            
    1053            
    1054            
    1055            
    1056            
    1057            
    1058            
    1059            
    1060            
    1061            
    1062            
    1063            
    1064            
    1065            
    1066            
    1067            
    1068            
    1069            
    1070            
    1071            
    1072            
    1073            
    1074            
    1075            
    1076            
    1077            
    1078            
    1079            
    1080            
    1081            
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   23

    1082            
    1083            
    1084            
    1085            
    1086            
    1087            
    1088            
    1089            
    1090            
    1091            
    1092            
    1093            
    1094            
    1095            
    1096            
    1097            
    1098            
    1099            
    1100            
    1101            
    1102             
    1103             
    1104             
    1105             
    1106            
    1107            
    1108            
    1109            
    1110            
    1111            
    1112            
    1113            
    1114            
    1115            
    1116            
    1117            
    1118            
    1119            
    1120            
    1121            
    1122            
    1123            
    1124            
    1125            
    1126            
    1127            
    1128            
    1129            
    1130            
    1131            
    1132            
    1133            
    1134            
    1135            
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   24

    1136            
    1137            
    1138            
    1139            
    1140            
    1141            
    1142            
    1143            
    1144            
    1145            
    1146            
    1147            
    1148            
    1149            
    1150            
    1151            
    1152            
    1153            
    1154            
    1155            
    1156            
    1157            
    1158            
    1159            
    1160            
    1161            
    1162            
    1163            
    1164            
    1165            
    1166            
    1167            
    1168            
    1169            
    1170            
    1171            
    1172            
    1173            
    1174            
    1175            
    1176            
    1177            
    1178            
    1179            
    1180            
    1181            
    1182            
    1183            
    1184            
    1185            
    1186            
    1187            
    1188            
    1189            
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   25

    1190             
    1191                    .if 0
    1192            
    1193            ;Code scraps:
    1194                            
    1195            ;**********************************************************************
    1196                            .global _fir2_20        ; declare function as global so c-code can find it
    1197            _fir2_20:       ; FIR filter, 2 channels, s1 = 20
    1198            ;               setc    OVM             ; set overflow mode to hard limit accumulations (for s2=0)
    1199            ;               spm             0                               ; clear product shift mode bits (PM)
    1200            
    1201            ; ch a:
    1202                            lacl    _in_a                   ; in -> ACC
    1203                            lar             AR2, _data_ptr_a ; point to state data location d0
    1204                            sacl    *,AR0           ; ACC -> d0
    1205                            lar             AR0, _data_ptr  ; point to first state data addr used (_data_ptr) -> AR0
    1206             
    1207                            lacl    #0                              ; 0 -> ACC
    1208                            mpy             #0                              ; 0 -> P
    1209                            mac             0ff00h,*-               ; ACC + shifted(P) -> ACC
    1210                                                                            ; d(N-1) -> T
    1211                                                                            ; d(N-1) * coef(N-1) -> P
    1212                            rpt             _orderm2                ; i = 2 to N (_orderm2 = N - 2)
    1213                            macd    0ff01h, *-              ; ACC + shifted(P) -> ACC
    1214                                                                            ; d(N-i) -> T
    1215                                                                            ; d(N-i) * coef(N-i) -> P
    1216                                                                            ; d(N-i) -> d(N-i+1)
    1217                            apac                                    ; ACC + shifted(P) -> ACC
    1218                            sach    _out_a,2                ; shifted(ACC) -> out (shift by s2)
    1219            ; Hard limit if there was a positive or negative overflow (only use if s2~=0):
    1220                            bcnd    fir2_20neg_a,LT ; branch if ACC<0
    1221                            and             #6000h,16       ; check for high order bits set
    1222                            bcnd    fir2_20done_a,EQ        ; no pos. overflow if ACC=0
    1223                            splk    #7fffh,_out_a ; save most pos. value
    1224                            b               fir2_20done_a
    1225            fir2_20neg_a:
    1226                            and             #6000h,16       ; mask of all but high order bits
    1227                            xor             #6000h,16       ; negate high order bits
    1228                            bcnd    fir2_20done_a,EQ        ; no neg. overflow if ACC=0
    1229                            splk    #8000h,_out_a   ; save most neg. value
    1230            fir2_20done_a:
    1231            
    1232            ; ch b:
    1233                            mar             *,AR2                   ; AR2 -> ARP
    1234                            lacl    _in_b                   ; in -> ACC
    1235                            lar             AR2, _data_ptr_b ; point to state data location d0
    1236                            sacl    *,AR0           ; ACC -> d0
    1237            
    1238                            lacl    #0                              ; 0 -> ACC
    1239                            mpy             #0                              ; 0 -> P
    1240                            mac             0ff80h,*-               ; ACC + shifted(P) -> ACC
    1241                                                                            ; d(N-1) -> T
    1242                                                                            ; d(N-1) * coef(N-1) -> P
    1243                            rpt             _orderm2                ; i = 2 to N (_orderm2 = N - 2)
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   26

    1244                            macd    0ff81h, *-              ; ACC + shifted(P) -> ACC
    1245                                                                            ; d(N-i) -> T
    1246                                                                            ; d(N-i) * coef(N-i) -> P
    1247                                                                            ; d(N-i) -> d(N-i+1)
    1248                            apac                                    ; ACC + shifted(P) -> ACC
    1249                            sach    _out_b,2                ; shifted(ACC) -> out (shift by s2)
    1250            ; Hard limit if there was a positive or negative overflow (only use if s2~=0):
    1251                            bcnd    fir2_20neg_b,LT ; branch if ACC<0
    1252                            and             #6000h,16       ; check for high order bits set
    1253                            bcnd    fir2_20done_b,EQ        ; no pos. overflow if ACC=0
    1254                            splk    #7fffh,_out_b ; save most pos. value
    1255                            b               fir2_20done_b
    1256            fir2_20neg_b:
    1257                            and             #6000h,16       ; mask of all but high order bits
    1258                            xor             #6000h,16       ; negate high order bits
    1259                            bcnd    fir2_20done_b,EQ        ; no neg. overflow if ACC=0
    1260                            splk    #8000h,_out_b   ; save most neg. value
    1261            fir2_20done_b:
    1262                            ret
    1263                            
    1264            ;**********************************************************************
    1265                            .global _fir2_21        ; declare function as global so c-code can find it
    1266            _fir2_21:       ; FIR filter, 2 channels, s1 = 21
    1267            ;               setc    OVM             ; set overflow mode to hard limit accumulations (for s2=0)
    1268            ;               spm             0                               ; clear product shift mode bits (PM)
    1269            
    1270            ; ch a:
    1271                            lacl    _in_a                   ; in -> ACC
    1272                            lar             AR2, _data_ptr_a ; point to state data location d0
    1273                            sacl    *,AR0           ; ACC -> d0
    1274                            lar             AR0, _data_ptr  ; point to first state data addr used (_data_ptr) -> AR0
    1275             
    1276                            lacl    #0                              ; 0 -> ACC
    1277                            mpy             #0                              ; 0 -> P
    1278                            mac             0ff00h,*-               ; ACC + shifted(P) -> ACC
    1279                                                                            ; d(N-1) -> T
    1280                                                                            ; d(N-1) * coef(N-1) -> P
    1281                            rpt             _orderm2                ; i = 2 to N (_orderm2 = N - 2)
    1282                            macd    0ff01h, *-              ; ACC + shifted(P) -> ACC
    1283                                                                            ; d(N-i) -> T
    1284                                                                            ; d(N-i) * coef(N-i) -> P
    1285                                                                            ; d(N-i) -> d(N-i+1)
    1286                            apac                                    ; ACC + shifted(P) -> ACC
    1287                            sach    _out_a,1                ; shifted(ACC) -> out (shift by s2)
    1288            ; Hard limit if there was a positive or negative overflow (only use if s2~=0):
    1289                            bcnd    fir2_21neg_a,LT ; branch if ACC<0
    1290                            and             #4000h,16       ; check for high order bits set
    1291                            bcnd    fir2_21done_a,EQ        ; no pos. overflow if ACC=0
    1292                            splk    #7fffh,_out_a ; save most pos. value
    1293                            b               fir2_21done_a
    1294            fir2_21neg_a:
    1295                            and             #4000h,16       ; mask of all but high order bits
    1296                            xor             #4000h,16       ; negate high order bits
    1297                            bcnd    fir2_21done_a,EQ        ; no neg. overflow if ACC=0
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   27

    1298                            splk    #8000h,_out_a   ; save most neg. value
    1299            fir2_21done_a:
    1300            
    1301            ; ch b:
    1302                            mar             *,AR2                   ; AR2 -> ARP
    1303                            lacl    _in_b                   ; in -> ACC
    1304                            lar             AR2, _data_ptr_b ; point to state data location d0
    1305                            sacl    *,AR0           ; ACC -> d0
    1306            
    1307                            lacl    #0                              ; 0 -> ACC
    1308                            mpy             #0                              ; 0 -> P
    1309                            mac             0ff80h,*-               ; ACC + shifted(P) -> ACC
    1310                                                                            ; d(N-1) -> T
    1311                                                                            ; d(N-1) * coef(N-1) -> P
    1312                            rpt             _orderm2                ; i = 2 to N (_orderm2 = N - 2)
    1313                            macd    0ff81h, *-              ; ACC + shifted(P) -> ACC
    1314                                                                            ; d(N-i) -> T
    1315                                                                            ; d(N-i) * coef(N-i) -> P
    1316                                                                            ; d(N-i) -> d(N-i+1)
    1317                            apac                                    ; ACC + shifted(P) -> ACC
    1318                            sach    _out_b,1                ; shifted(ACC) -> out (shift by s2)
    1319            ; Hard limit if there was a positive or negative overflow (only use if s2~=0):
    1320                            bcnd    fir2_21neg_b,LT ; branch if ACC<0
    1321                            and             #4000h,16       ; check for high order bits set
    1322                            bcnd    fir2_21done_b,EQ        ; no pos. overflow if ACC=0
    1323                            splk    #7fffh,_out_b ; save most pos. value
    1324                            b               fir2_21done_b
    1325            fir2_21neg_b:
    1326                            and             #4000h,16       ; mask of all but high order bits
    1327                            xor             #4000h,16       ; negate high order bits
    1328                            bcnd    fir2_21done_b,EQ        ; no neg. overflow if ACC=0
    1329                            splk    #8000h,_out_b   ; save most neg. value
    1330            fir2_21done_b:
    1331                            ret
    1332                            
    1333            ;**********************************************************************
    1334                            .global _fir2_22        ; declare function as global so c-code can find it
    1335            _fir2_22:       ; FIR filter, 2 channels, s1 = 22
    1336                            setc    OVM             ; set overflow mode to hard limit accumulations (for s2=0)
    1337            ;               spm             0                               ; clear product shift mode bits (PM)
    1338            
    1339            ; ch a:
    1340                            lacl    _in_a                   ; in -> ACC
    1341                            lar             AR2, _data_ptr_a ; point to state data location d0
    1342                            sacl    *,AR0           ; ACC -> d0
    1343                            lar             AR0, _data_ptr  ; point to first state data addr used (_data_ptr) -> AR0
    1344             
    1345                            lacl    #0                              ; 0 -> ACC
    1346                            mpy             #0                              ; 0 -> P
    1347                            mac             0ff00h,*-               ; ACC + shifted(P) -> ACC
    1348                                                                            ; d(N-1) -> T
    1349                                                                            ; d(N-1) * coef(N-1) -> P
    1350                            rpt             _orderm2                ; i = 2 to N (_orderm2 = N - 2)
    1351                            macd    0ff01h, *-              ; ACC + shifted(P) -> ACC
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   28

    1352                                                                            ; d(N-i) -> T
    1353                                                                            ; d(N-i) * coef(N-i) -> P
    1354                                                                            ; d(N-i) -> d(N-i+1)
    1355                            apac                                    ; ACC + shifted(P) -> ACC
    1356                            sach    _out_a,0                ; shifted(ACC) -> out (shift by s2)
    1357            
    1358            ; ch b:
    1359                            mar             *,AR2                   ; AR2 -> ARP
    1360                            lacl    _in_b                   ; in -> ACC
    1361                            lar             AR2, _data_ptr_b ; point to state data location d0
    1362                            sacl    *,AR0           ; ACC -> d0
    1363            
    1364                            lacl    #0                              ; 0 -> ACC
    1365                            mpy             #0                              ; 0 -> P
    1366                            mac             0ff80h,*-               ; ACC + shifted(P) -> ACC
    1367                                                                            ; d(N-1) -> T
    1368                                                                            ; d(N-1) * coef(N-1) -> P
    1369                            rpt             _orderm2                ; i = 2 to N (_orderm2 = N - 2)
    1370                            macd    0ff81h, *-              ; ACC + shifted(P) -> ACC
    1371                                                                            ; d(N-i) -> T
    1372                                                                            ; d(N-i) * coef(N-i) -> P
    1373                                                                            ; d(N-i) -> d(N-i+1)
    1374                            apac                                    ; ACC + shifted(P) -> ACC
    1375                            sach    _out_b,0                ; shifted(ACC) -> out (shift by s2)
    1376                            ret
    1377            
    1378                            
    1379            ; Hard limit if there was a positive or negative overflow (only use if s2~=0):
    1380            ; Fix: consider getting rid of this limiter: it only works if there is no ACC
    1381            ; overflow, and seting overflow mode only slightly reduces dynamic range in the
    1382            ; compared to a valid data wraparound.
    1383                            bcnd    fir2_15neg_b,LT ; branch if ACC<0
    1384                            and             #4000h,16       ; check for high order bits set
    1385                            bcnd    fir2_15done_b,EQ        ; no pos. overflow if ACC=0
    1386                            splk    #7fffh,_out_b ; save most pos. value
    1387                            b               fir2_15done_b
    1388            fir2_15neg_b:
    1389                            and             #4000h,16       ; mask of all but high order bits
    1390                            xor             #4000h,16       ; negate high order bits
    1391                            bcnd    fir2_15done_b,EQ        ; no neg. overflow if ACC=0
    1392                            splk    #8000h,_out_b   ; save most neg. value
    1393            fir2_15done_b:
    1394            
    1395            
    1396            
    1397            ; Direct memory access SOS's            
    1398            ;   ldp #_coefdata
    1399            ;               lt              _d11a           ; d2 -> T
    1400            ;               mpy             *+              ; T*a2 -> P
    1401            ;               lta             _d21a           ; d1 -> T, ACC+P -> ACC
    1402            ;               mpy             *+              ; T*a1 -> P
    1403            ;               apac                            ; ACC+P -> ACC
    1404            ;               sach    _d01a,1 ; shifted(ACC) -> d0 (shift by s2 = 16-s1)
    1405            ;               lacl    #0                      ; 0 -> ACC
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   29

    1406            ;               mpy             *+              ; T*b2 -> P
    1407            ;               ltd             _d11a           ; d1 -> T, d1 -> d2, ACC+P -> ACC
    1408            ;               mpy             *+              ; T*b1 -> P
    1409            ;               ltd             _d01a           ; d0 -> T, d0 -> d1, ACC+P -> ACC
    1410            ;               mpy             *+              ; T*b0 -> P
    1411                            
    1412            ;               lta             _d12a           ; d2 -> T, ACC+P -> ACC
    1413            ;               mpy             *+              ; T*a2 -> P
    1414            ;               lta             _d22a           ; d1 -> T, ACC+P -> ACC
    1415            ;               mpy             *+              ; T*a1 -> P
    1416            ;               apac                            ; ACC+P -> ACC
    1417            ;               sach    _d02a,1 ; shifted(ACC) -> d0 (shift by s2 = 16-s1)
    1418            ;               lacl    #0                      ; 0 -> ACC
    1419            ;               mpy             *+              ; T*b2 -> P
    1420            ;               ltd             _d12a           ; d1 -> T, d1 -> d2, ACC+P -> ACC
    1421            ;               mpy             *+              ; T*b1 -> P
    1422            ;               ltd             _d02a           ; d0 -> T, d0 -> d1, ACC+P -> ACC
    1423            ;               mpy             *+              ; T*b0 -> P
    1424            ;   ldp #temp
    1425            
    1426            ;**********************************************************************
    1427            ; FIR Filter functions (fix: old dump)
    1428            ; Use different function for different max impulse response value:
    1429            ;                                               fir2_15 - 2 channel, s1=15, s2=0, PM=1
    1430            ;                                               fir2_16 - 2 channel, s1=16, s2=0, PM=0
    1431            ;
    1432            ;                                               fir1_15 - 1 channel, s1=15, s2=0, PM=1
    1433            ;                                               fir1_16 - 1 channel, s1=16, s2=0, PM=0
    1434            ;
    1435            ; C-code sets the following values:
    1436            ;
    1437            ;       _func_addr              =       address of function to call
    1438            ;       _orderm2                =       N - 2, N=2 to 128 for 2 ch, or to 256 for 1 ch filters
    1439            ;       _data_ptr               =       points to address first used of filter state data (usualy 03ffh)
    1440            ;       _data_ptr_a     =       _data_ptr-N+1, (points to first address filter data ch a: d0)
    1441            ;       _data_ptr_b     =       _data_ptr-2*N+1, (points to first address filter data ch b: d0)
    1442            ;
    1443            ;               _data_ptr_b:    d0              - ch b
    1444            ;                                               d1 ...
    1445            ;                                               d(N-1)
    1446            ;               _data_ptr_a:    d0              - ch a
    1447            ;                                               d1 ...
    1448            ;               _data_ptr:              d(N-1)
    1449            ;
    1450            ;       _fir_coef[]     =       array of coeficient data:       fir_coef[0] = h(N-1) - ch a
    1451            ;               Clear CNF bit to write fir_coef[]                       fir_coef[1] = h(N-2)
    1452            ;               Then set CNF bit to map to prog memory.         ...
    1453            ;                                                                                                       fir_coef
    1454            ;
    1455            ;                                                                                                       fir_coef
    1456            ;                                                                                                       fir_coef
    1457            ;                                                                                                       ...
    1458            ;                                                                                                       fir_coef
    1459            ;
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   30

    1460            ; Coeficent values are stored = int or round[(2^s1)*true_coef_value]
    1461            ;
    1462            ; For optimum scaling use different functions for different maximum
    1463            ; impulse response values as follows:
    1464            ; coef scaling shift: s1 = 16 - s2 - PM
    1465            ; output shift:           s2 = 16 - s1 + PM
    1466            ; Valid combinations (assuming truncation of scaled ideal coefs):
    1467            ;                       max(h)                  use:    s1      s2      PM      function
    1468            ;               [0.5       to 1)                        15      0       1       _firX_15
    1469            ;               [0         to 0.5)                      16      0       0       _firX_16
    1470            ;
    1471            ;               [0.015625  to 0.03125)          _firX_20 (not used)
    1472            ;               [0.0078125 to 0.015625)         _firX_21 (not used)
    1473            ;               [0         to 0.0078125)        _firX_22 (not used)
    1474            ;                                               
    1475            ;**********************************************************************
    1476                            .global _fir2_15        ; declare function as global so c-code can find it
    1477            _fir2_15:       ; FIR filter, 2 channels, s1 = 15
    1478                            spm             1                               ; set product mode (PM) to 1
    1479            
    1480            ; ch a:
    1481                            lacl    _in_a                   ; in -> ACC
    1482                            lar             AR2, _data_ptr_a ; point to state data location d0
    1483                            sacl    *,AR0           ; ACC -> d0
    1484                            lar             AR0, _data_ptr  ; point to first state data addr used (_data_ptr) -> AR0
    1485             
    1486                            lacl    #0                              ; 0 -> ACC
    1487                            mpy             #0                              ; 0 -> P
    1488                            mac             0ff00h,*-               ; ACC + shifted(P) -> ACC
    1489                                                                            ; d(N-1) -> T
    1490                                                                            ; d(N-1) * coef(N-1) -> P
    1491                            rpt             _orderm2                ; i = 2 to N (_orderm2 = N - 2)
    1492                            macd    0ff01h, *-              ; ACC + shifted(P) -> ACC
    1493                                                                            ; d(N-i) -> T
    1494                                                                            ; d(N-i) * coef(N-i) -> P
    1495                                                                            ; d(N-i) -> d(N-i+1)
    1496                            apac                                    ; ACC + shifted(P) -> ACC
    1497                            sach    _out_a,0                ; shifted(ACC) -> out (shift by s2)
    1498            
    1499            ; ch b:
    1500                            mar             *,AR2                   ; AR2 -> ARP
    1501                            lacl    _in_b                   ; in -> ACC
    1502                            lar             AR2, _data_ptr_b ; point to state data location d0
    1503                            sacl    *,AR0           ; ACC -> d0
    1504            
    1505                            lacl    #0                              ; 0 -> ACC
    1506                            mpy             #0                              ; 0 -> P
    1507                            mac             0ff80h,*-               ; ACC + shifted(P) -> ACC
    1508                                                                            ; d(N-1) -> T
    1509                                                                            ; d(N-1) * coef(N-1) -> P
    1510                            rpt             _orderm2                ; i = 2 to N (_orderm2 = N - 2)
    1511                            macd    0ff81h, *-              ; ACC + shifted(P) -> ACC
    1512                                                                            ; d(N-i) -> T
    1513                                                                            ; d(N-i) * coef(N-i) -> P
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   31

    1514                                                                            ; d(N-i) -> d(N-i+1)
    1515                            apac                                    ; ACC + shifted(P) -> ACC
    1516                            sach    _out_b,0                ; shifted(ACC) -> out (shift by s2)
    1517                            ret
    1518                            
    1519            ;**********************************************************************
    1520                            .global _fir2_16        ; declare function as global so c-code can find it
    1521            _fir2_16:       ; FIR filter, 2 channels, s1 = 16
    1522            ;               spm             0                               ; clear product shift mode bits (PM) (this is al
    1523            
    1524            ; ch a:
    1525                            lacl    _in_a                   ; in -> ACC
    1526                            lar             AR2, _data_ptr_a ; point to state data location d0
    1527                            sacl    *,AR0           ; ACC -> d0
    1528                            lar             AR0, _data_ptr  ; point to first state data addr used (_data_ptr) -> AR0
    1529             
    1530                            lacl    #0                              ; 0 -> ACC
    1531                            mpy             #0                              ; 0 -> P
    1532                            mac             0ff00h,*-               ; ACC + shifted(P) -> ACC
    1533                                                                            ; d(N-1) -> T
    1534                                                                            ; d(N-1) * coef(N-1) -> P
    1535                            rpt             _orderm2                ; i = 2 to N (_orderm2 = N - 2)
    1536                            macd    0ff01h, *-              ; ACC + shifted(P) -> ACC
    1537                                                                            ; d(N-i) -> T
    1538                                                                            ; d(N-i) * coef(N-i) -> P
    1539                                                                            ; d(N-i) -> d(N-i+1)
    1540                            apac                                    ; ACC + shifted(P) -> ACC
    1541                            sach    _out_a,0                ; shifted(ACC) -> out (shift by s2)
    1542                            
    1543            ; ch b:
    1544                            mar             *,AR2                   ; AR2 -> ARP
    1545                            lacl    _in_b                   ; in -> ACC
    1546                            lar             AR2, _data_ptr_b ; point to state data location d0
    1547                            sacl    *,AR0           ; ACC -> d0
    1548            
    1549                            lacl    #0                              ; 0 -> ACC
    1550                            mpy             #0                              ; 0 -> P
    1551                            mac             0ff80h,*-               ; ACC + shifted(P) -> ACC
    1552                                                                            ; d(N-1) -> T
    1553                                                                            ; d(N-1) * coef(N-1) -> P
    1554                            rpt             _orderm2                ; i = 2 to N (_orderm2 = N - 2)
    1555                            macd    0ff81h, *-              ; ACC + shifted(P) -> ACC
    1556                                                                            ; d(N-i) -> T
    1557                                                                            ; d(N-i) * coef(N-i) -> P
    1558                                                                            ; d(N-i) -> d(N-i+1)
    1559                            apac                                    ; ACC + shifted(P) -> ACC
    1560                            sach    _out_b,0                ; shifted(ACC) -> out (shift by s2)
    1561                            ret
    1562            
    1563            
    1564            
    1565            
    1566            
    1567            ;**********************************************************************
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   32

    1568            ; IIR Filter functions (this is old code):
    1569            ;                                               iir2_4  - 2 channel, 4th order
    1570            ;                                               iir2_8  - 2 channel, 8th order
    1571            ;                                               iir2_12 - 2 channel, 12th order
    1572            ;                                               iir2_16 - 2 channel, 16th order
    1573            ;                                               iir2_20 - 2 channel, 20th order
    1574            ;                                               iir2_24 - 2 channel, 24th order
    1575            ;
    1576            ;                                               iir1_4  - 1 channel, 4th order
    1577            ;                                               iir1_8  - 1 channel, 8th order
    1578            ;                                               iir1_12 - 1 channel, 12th order
    1579            ;                                               iir1_16 - 1 channel, 16th order
    1580            ;                                               iir1_20 - 1 channel, 20th order
    1581            ;                                               iir1_24 - 1 channel, 24th order
    1582            ;
    1583            ;
    1584            ; C-code sets the following values:
    1585            ;
    1586            ;       _func_addr              =       address of function to call
    1587            ;       _coef_ptr               =       points to first filter coeficient of ch a (in B0: 200h-2ffh):
    1588            ;
    1589            ;               _coef_ptr:              a21             - ch a, section 1
    1590            ;                                               a11
    1591            ;                                               b21
    1592            ;                                               b11
    1593            ;                                               b01
    1594            ;                                               a22             - ch a, section 2
    1595            ;                                               a12
    1596            ;                                               b22
    1597            ;                                               b12
    1598            ;                                               b02
    1599            ;                                               ... more sections
    1600            ;
    1601            ;                                               a21             - ch b, section 1
    1602            ;                                               ... same as ch a above
    1603            ;
    1604            ; Coeficent values are stored = int[(2^s1)*true_coef_value]
    1605            ;
    1606            ;       _data_ptr               =       points to first used address of filter state data (in B1: 300h-3ffh)
    1607            ;
    1608            ;                                               d01             - ch b, last section
    1609            ;                                               ...
    1610            ;                                               d02
    1611            ;                                               d12
    1612            ;                                               d22             - ch a, section 2
    1613            ;                                               d01
    1614            ;                                               d11
    1615            ;               _data_ptr:              d21             - ch a, section 1
    1616            
    1617            ;**********************************************************************
    1618                            .global _iir2_4 ; declare function as global so c-code can find it
    1619            _iir2_4:        ; 2 channel, forth order filter (2 SOS's):
    1620            ;       setc    OVM             ; set overflow mode to hard limit accumulations
    1621                            mar             *,AR0                   ; AR0 -> ARP
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   33

    1622                            lar             AR0,  #03ffh  ; point to first state data addr -> AR0
    1623                            
    1624            ; ch a:
    1625                            lacc    _in_a,15        ; shifted(in) -> ACC (shift by s1 = 16-s2)
    1626                            lt              *-,AR2          ; d2 -> T
    1627                            mpy             *+,AR0          ; T*a2 -> P
    1628                            lta             *+,AR2          ; d1 -> T, ACC+P -> ACC
    1629                            mpy             *+,AR0          ; T*a1 -> P
    1630                            lta     *-              ; d2 -> T, ACC+P -> ACC
    1631                            mar     *-                              ; AR0-1 -> AR0 (point to d0)
    1632                            sach    *+,1,AR2        ; shifted(ACC) -> d0 (shift by s2 = 16-s1)
    1633                            lacl    #0                      ; 0 -> ACC
    1634                            mpy             *+,AR0          ; T*b2 -> P
    1635                            ltd             *-,AR2          ; d1 -> T, d1 -> d2, ACC+P -> ACC
    1636                            mpy             *+,AR0          ; T*b1 -> P
    1637                            ltd             *-,AR2          ; d0 -> T, d0 -> d1, ACC+P -> ACC
    1638                            mpy             *+,AR0          ; T*b0 -> P
    1639            
    1640                            lta             *-,AR2          ; d2 -> T, ACC+P -> ACC
    1641                            mpy             *+,AR0          ; T*a2 -> P
    1642                            lta             *+,AR2          ; d1 -> T, ACC+P -> ACC
    1643                            mpy             *+,AR0          ; T*a1 -> P
    1644                            lta     *-              ; d2 -> T, ACC+P -> ACC
    1645                            mar     *-                              ; AR0-1 -> AR0 (point to d0)
    1646                            sach    *+,1,AR2        ; shifted(ACC) -> d0 (shift by s2 = 16-s1)
    1647                            lacl    #0                      ; 0 -> ACC
    1648                            mpy             *+,AR0          ; T*b2 -> P
    1649                            ltd             *-,AR2          ; d1 -> T, d1 -> d2, ACC+P -> ACC
    1650                            mpy             *+,AR0          ; T*b1 -> P
    1651                            ltd             *-,AR2          ; d0 -> T, d0 -> d1, ACC+P -> ACC
    1652                            mpy             *+,AR0          ; T*b0 -> P
    1653            
    1654                            apac
    1655                            sach    _out_a,1        ; shifted(ACC) -> out (shift by s2 = 16-s1)
    1656            
    1657                    b       iir2_4done_a
    1658            ; Hard limit if there was a positive or negative overflow (only use if s2 != 0):
    1659                            bcnd    iir2_4neg_a,LT  ; branch if ACC<0
    1660                            and             #4000h,16       ; check for high order bits set
    1661                            bcnd    iir2_4done_a,EQ ; no pos. overflow if ACC=0
    1662                            splk    #7fffh,_out_a ; save most pos. value
    1663                            b               iir2_4done_a
    1664            iir2_4neg_a:
    1665                            and             #4000h,16       ; mask of all but high order bits
    1666                            xor             #4000h,16       ; negate high order bits
    1667                            bcnd    iir2_4done_a,EQ ; no neg. overflow if ACC=0
    1668                            splk    #8000h,_out_a   ; save most neg. value
    1669            iir2_4done_a:
    1670            
    1671            ; ch b:
    1672                            lacc    _in_b,15        ; shifted(in) -> ACC (shift by s1 = 16-s2)
    1673                            lt              *-,AR2          ; d2 -> T
    1674                            mpy             *+,AR0          ; T*a2 -> P
    1675                            lta             *+,AR2          ; d1 -> T, ACC+P -> ACC
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   34

    1676                            mpy             *+,AR0          ; T*a1 -> P
    1677                            lta     *-              ; d2 -> T, ACC+P -> ACC
    1678                            mar     *-                              ; AR0-1 -> AR0 (point to d0)
    1679                            sach    *+,1,AR2        ; shifted(ACC) -> d0 (shift by s2 = 16-s1)
    1680                            lacl    #0                      ; 0 -> ACC
    1681                            mpy             *+,AR0          ; T*b2 -> P
    1682                            ltd             *-,AR2          ; d1 -> T, d1 -> d2, ACC+P -> ACC
    1683                            mpy             *+,AR0          ; T*b1 -> P
    1684                            ltd             *-,AR2          ; d0 -> T, d0 -> d1, ACC+P -> ACC
    1685                            mpy             *+,AR0          ; T*b0 -> P
    1686            
    1687                            lta             *-,AR2          ; d2 -> T, ACC+P -> ACC
    1688                            mpy             *+,AR0          ; T*a2 -> P
    1689                            lta             *+,AR2          ; d1 -> T, ACC+P -> ACC
    1690                            mpy             *+,AR0          ; T*a1 -> P
    1691                            lta     *-              ; d2 -> T, ACC+P -> ACC
    1692                            mar     *-                              ; AR0-1 -> AR0 (point to d0)
    1693                            sach    *+,1,AR2        ; shifted(ACC) -> d0 (shift by s2 = 16-s1)
    1694                            lacl    #0                      ; 0 -> ACC
    1695                            mpy             *+,AR0          ; T*b2 -> P
    1696                            ltd             *-,AR2          ; d1 -> T, d1 -> d2, ACC+P -> ACC
    1697                            mpy             *+,AR0          ; T*b1 -> P
    1698                            ltd             *-,AR2          ; d0 -> T, d0 -> d1, ACC+P -> ACC
    1699                            mpy             *+,AR0          ; T*b0 -> P
    1700            
    1701                            apac
    1702                            sach    _out_b,1        ; shifted(ACC) -> out (shift by s2 = 16-s1)
    1703            
    1704                    b       iir2_4done_b
    1705            ; Hard limit if there was a positive or negative overflow (only use if s2 != 0):
    1706                            bcnd    iir2_4neg_b,LT  ; branch if ACC<0
    1707                            and             #4000h,16       ; check for high order bits set
    1708                            bcnd    iir2_4done_b,EQ ; no pos. overflow if ACC=0
    1709                            splk    #7fffh,_out_b ; save most pos. value
    1710                            b               iir2_4done_b
    1711            iir2_4neg_b:
    1712                            and             #4000h,16       ; mask of all but high order bits
    1713                            xor             #4000h,16       ; negate high order bits
    1714                            bcnd    iir2_4done_b,EQ ; no neg. overflow if ACC=0
    1715                            splk    #8000h,_out_b   ; save most neg. value
    1716            iir2_4done_b:
    1717                    
    1718                            ret
    1719                            
    1720            ;**********************************************************************
    1721                            .global _iir1_4 ; declare function as global so c-code can find it
    1722            _iir1_4:        ; 1 channel, forth order filter (2 SOS's):
    1723            ;       setc    OVM             ; set overflow mode to hard limit accumulations
    1724                            mar             *,AR0                   ; AR0 -> ARP
    1725                            lar             AR0, #03ffh  ; point to first state data addr used -> AR0
    1726                            
    1727                            lacc    _in_a,15        ; shifted(in) -> ACC (shift by s1 = 16-s2)
    1728            
    1729                            lt              *-,AR2          ; d2 -> T
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   35

    1730                            mpy             *+,AR0          ; T*a2 -> P
    1731                            lta             *+,AR2          ; d1 -> T, ACC+P -> ACC
    1732                            mpy             *+,AR0          ; T*a1 -> P
    1733                            lta     *-              ; d2 -> T, ACC+P -> ACC
    1734                            mar     *-                              ; AR0-1 -> AR0 (point to d0)
    1735                            sach    *+,1,AR2        ; shifted(ACC) -> d0 (shift by s2 = 16-s1)
    1736                            lacl    #0                      ; 0 -> ACC
    1737                            mpy             *+,AR0          ; T*b2 -> P
    1738                            ltd             *-,AR2          ; d1 -> T, d1 -> d2, ACC+P -> ACC
    1739                            mpy             *+,AR0          ; T*b1 -> P
    1740                            ltd             *-,AR2          ; d0 -> T, d0 -> d1, ACC+P -> ACC
    1741                            mpy             *+,AR0          ; T*b0 -> P
    1742            
    1743                            lta             *-,AR2          ; d2 -> T, ACC+P -> ACC
    1744                            mpy             *+,AR0          ; T*a2 -> P
    1745                            lta             *+,AR2          ; d1 -> T, ACC+P -> ACC
    1746                            mpy             *+,AR0          ; T*a1 -> P
    1747                            lta     *-              ; d2 -> T, ACC+P -> ACC
    1748                            mar     *-                              ; AR0-1 -> AR0 (point to d0)
    1749                            sach    *+,1,AR2        ; shifted(ACC) -> d0 (shift by s2 = 16-s1)
    1750                            lacl    #0                      ; 0 -> ACC
    1751                            mpy             *+,AR0          ; T*b2 -> P
    1752                            ltd             *-,AR2          ; d1 -> T, d1 -> d2, ACC+P -> ACC
    1753                            mpy             *+,AR0          ; T*b1 -> P
    1754                            ltd             *-,AR2          ; d0 -> T, d0 -> d1, ACC+P -> ACC
    1755                            mpy             *+,AR0          ; T*b0 -> P
    1756            
    1757                            apac
    1758                            sach    _out_a,1        ; shifted(ACC) -> out (shift by s2 = 16-s1)
    1759            
    1760            ; Hard limit if there was a positive or negative overflow (only use if s2 != 0):
    1761                            bcnd    iir1_4neg,LT    ; branch if ACC<0
    1762                            and             #4000h,16       ; check for high order bits set
    1763                            bcnd    iir1_4done,EQ   ; no pos. overflow if ACC=0
    1764                            splk    #7fffh,_out_a ; save most pos. value
    1765                            b               iir1_4done
    1766            iir1_4neg:
    1767                            and             #4000h,16       ; mask of all but high order bits
    1768                            xor             #4000h,16       ; negate high order bits
    1769                            bcnd    iir1_4done,EQ   ; no neg. overflow if ACC=0
    1770                            splk    #8000h,_out_a   ; save most neg. value
    1771            iir1_4done:
    1772                            ret
    1773            
    1774            
    1775            ;**********************************************************************
    1776            ; IIR Filter functions (this is the latest IIR code):
    1777            ;                                               iir_4_a         - Channel A, 4th order
    1778            ;                                               iir_4_b         - Channel B, 4th order
    1779            ;                                               iir_8_a         - Channel A, 8th order
    1780            ;                                               iir_8_b         - Channel B, 8th order
    1781            ;                                               iir_12_a        - Channel A, 12th order
    1782            ;                                               iir_12_b        - Channel B, 12th order
    1783            ;                                               iir_16_a        - Channel A, 16th order
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   36

    1784            ;                                               iir_16_b        - Channel B, 16th order
    1785            ;                                               iir_20_a        - Channel A, 20th order
    1786            ;                                               iir_20_b        - Channel B, 20th order
    1787            ;                                               iir_24_a        - Channel A, 24th order
    1788            ;                                               iir_24_b        - Channel B, 24th order
    1789            ;
    1790            ; C-code sets the following values:
    1791            ;
    1792            ;       _func_addr_a    =       address of Ch A function
    1793            ;       _func_addr_b    =       address of Ch B function
    1794            ;
    1795            ;       _coef_ptr_b             =       points to first filter coeficient  Ch B (in B1: 300h):
    1796            ;       _data_ptr_b             =       points to first used state address Ch B (in B1: 37fh)
    1797            ;       _coef_ptr_a             =       points to first filter coeficient  Ch A (in B1: 380h):
    1798            ;       _data_ptr_a             =       points to first used state address Ch A (in B1: 3ffh)
    1799            ;
    1800            ; 300h  _coef_ptr_b:    a21             - Ch B, section 1
    1801            ;                                               a11
    1802            ;                                               b21
    1803            ;                                               b11
    1804            ;                                               b01
    1805            ;                                               a22             - Ch B, section 2
    1806            ;                                               a12
    1807            ;                                               b22
    1808            ;                                               b12
    1809            ;                                               b02
    1810            ;                                               ... more sections (coef and data grow towards each other)
    1811            ;
    1812            ;                                               ...
    1813            ;                                               d02
    1814            ;                                               d12
    1815            ;                                               d22             - Ch B, section 2
    1816            ;                                               d01
    1817            ;                                               d11
    1818            ; 37fh  _data_ptr_b:    d21             - Ch B, section 1
    1819            ;
    1820            ;
    1821            ; 380h  _coef_ptr_a:    a21             - Ch A, section 1
    1822            ;                                               a11
    1823            ;                                               b21
    1824            ;                                               b11
    1825            ;                                               b01
    1826            ;                                               a22             - Ch A, section 2
    1827            ;                                               a12
    1828            ;                                               b22
    1829            ;                                               b12
    1830            ;                                               b02
    1831            ;                                               ... more sections (coef and data grow towards each other)
    1832            ;
    1833            ;                                               ...
    1834            ;                                               d02
    1835            ;                                               d12
    1836            ;                                               d22             - Ch A, section 2
    1837            ;                                               d01
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   37

    1838            ;                                               d11
    1839            ; 3ffh  _data_ptr_a:    d21             - Ch A, section 1
    1840            ;
    1841            ;
    1842            ; Coeficent values are stored = int[(2^s1)*true_coef_value]
    1843            ;                                                               with: s1 = 14  => int[16384*true_coef_value]
    1844            ;
    1845            ;**********************************************************************
    1846                            .global _iir_4_a        ; declare function as global so c-code can find it
    1847            _iir_4_a:       ; Ch A, Forth order filter (2 SOS's):
    1848                            lacc    _in_a,14        ; shifted(Ch A in) -> ACC (shift by s1 = 16-s2)
    1849            
    1850                            spm             0                       ; clear product mode (PM) to 0
    1851                            lar             AR2, _coef_ptr_a ; point to first coef address
    1852                            lar             AR0, _data_ptr_a ; point to state data location d0
    1853                            mar             *,AR0           ; AR0 -> ARP
    1854                            
    1855                            lt              *-,AR2          ; d2 -> T
    1856                            mpy             *+,AR0          ; T*a2 -> P
    1857                            lts             *+,AR2          ; d1 -> T, ACC-P -> ACC
    1858                            mpy             *+,AR0          ; T*a1 -> P
    1859                            lts     *-              ; d2 -> T, ACC-P -> ACC
    1860                            mar     *-                              ; AR0-1 -> AR0 (point to d0)
    1861                            sach    *+,2,AR2        ; shifted(ACC) -> d0 (shift by s2 = 16-s1)
    1862                            lacl    #0                      ; 0 -> ACC
    1863                            mpy             *+,AR0          ; T*b2 -> P
    1864                            ltd             *-,AR2          ; d1 -> T, d1 -> d2, ACC+P -> ACC
    1865                            mpy             *+,AR0          ; T*b1 -> P
    1866                            ltd             *-,AR2          ; d0 -> T, d0 -> d1, ACC+P -> ACC
    1867                            mpy             *+,AR0          ; T*b0 -> P
    1868            
    1869                            lta             *-,AR2          ; d2 -> T, ACC+P -> ACC
    1870                            mpy             *+,AR0          ; T*a2 -> P
    1871                            lts             *+,AR2          ; d1 -> T, ACC-P -> ACC
    1872                            mpy             *+,AR0          ; T*a1 -> P
    1873                            lts     *-              ; d2 -> T, ACC-P -> ACC
    1874                            mar     *-                              ; AR0-1 -> AR0 (point to d0)
    1875                            sach    *+,2,AR2        ; shifted(ACC) -> d0 (shift by s2 = 16-s1)
    1876                            lacl    #0                      ; 0 -> ACC
    1877                            mpy             *+,AR0          ; T*b2 -> P
    1878                            ltd             *-,AR2          ; d1 -> T, d1 -> d2, ACC+P -> ACC
    1879                            mpy             *+,AR0          ; T*b1 -> P
    1880                            ltd             *-,AR2          ; d0 -> T, d0 -> d1, ACC+P -> ACC
    1881                            mpy             *+,AR0          ; T*b0 -> P
    1882            
    1883                            apac
    1884                            sach    _out_a,2        ; shifted(ACC) -> out (shift by s2 = 16-s1)
    1885            
    1886            ; End of Ch A
    1887                            lacl    _func_addr_b    ; get the current B function address ...
    1888                            bacc                                    ; and branch to it
    1889            
    1890            
    1891            ;**********************************************************************
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   38

    1892                            .global _iir_4_b        ; declare function as global so c-code can find it
    1893            _iir_4_b:       ; Ch B, Forth order filter (2 SOS's):
    1894            
    1895            ; Start of Ch B
    1896                            lacc    _in_b,14        ; shifted(Ch B in) -> ACC (shift by s1 = 16-s2)
    1897                            bit             _assembly_flag, 13      ; cascade_flag -> TC
    1898                            bcnd    iir_4_skip,NTC  ; skip cascade hold if flag not set
    1899                            lacc    _out_a,14       ; shifted(Ch A out) -> ACC (shift by s1 = 16-s2)
    1900            iir_4_skip:
    1901            
    1902                            spm             0                       ; clear product mode (PM) to 0
    1903                            lar             AR2, _coef_ptr_b ; point to first coef address
    1904                            lar             AR0, _data_ptr_b ; point to state data location d0
    1905                            mar             *,AR0           ; AR0 -> ARP
    1906                            
    1907                            lt              *-,AR2          ; d2 -> T
    1908                            mpy             *+,AR0          ; T*a2 -> P
    1909                            lts             *+,AR2          ; d1 -> T, ACC-P -> ACC
    1910                            mpy             *+,AR0          ; T*a1 -> P
    1911                            lts     *-              ; d2 -> T, ACC-P -> ACC
    1912                            mar     *-                              ; AR0-1 -> AR0 (point to d0)
    1913                            sach    *+,2,AR2        ; shifted(ACC) -> d0 (shift by s2 = 16-s1)
    1914                            lacl    #0                      ; 0 -> ACC
    1915                            mpy             *+,AR0          ; T*b2 -> P
    1916                            ltd             *-,AR2          ; d1 -> T, d1 -> d2, ACC+P -> ACC
    1917                            mpy             *+,AR0          ; T*b1 -> P
    1918                            ltd             *-,AR2          ; d0 -> T, d0 -> d1, ACC+P -> ACC
    1919                            mpy             *+,AR0          ; T*b0 -> P
    1920            
    1921                            lta             *-,AR2          ; d2 -> T, ACC+P -> ACC
    1922                            mpy             *+,AR0          ; T*a2 -> P
    1923                            lts             *+,AR2          ; d1 -> T, ACC-P -> ACC
    1924                            mpy             *+,AR0          ; T*a1 -> P
    1925                            lts     *-              ; d2 -> T, ACC-P -> ACC
    1926                            mar     *-                              ; AR0-1 -> AR0 (point to d0)
    1927                            sach    *+,2,AR2        ; shifted(ACC) -> d0 (shift by s2 = 16-s1)
    1928                            lacl    #0                      ; 0 -> ACC
    1929                            mpy             *+,AR0          ; T*b2 -> P
    1930                            ltd             *-,AR2          ; d1 -> T, d1 -> d2, ACC+P -> ACC
    1931                            mpy             *+,AR0          ; T*b1 -> P
    1932                            ltd             *-,AR2          ; d0 -> T, d0 -> d1, ACC+P -> ACC
    1933                            mpy             *+,AR0          ; T*b0 -> P
    1934            
    1935                            apac
    1936                            sach    _out_b,2        ; shifted(ACC) -> out (shift by s2 = 16-s1)
    1937            
    1938                            ret
    1939                            
    1940             
    1941            ;**********************************************************************
    1942            ; Lattice Filter functions:
    1943            ;                                               lattice_2_a             - Channel A, 2nd order
    1944            ;                                               lattice_2_b             - Channel B, 2nd order
    1945            ;                                               lattice_4_a             - Channel A, 4th order
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   39

    1946            ;                                               lattice_4_b             - Channel B, 4th order
    1947            ;                                               lattice_8_a             - Channel A, 8th order
    1948            ;                                               lattice_8_b             - Channel B, 8th order
    1949            ;                                               lattice_12_a    - Channel A, 12th order
    1950            ;                                               lattice_12_b    - Channel B, 12th order
    1951            ;                                               lattice_16_a    - Channel A, 16th order
    1952            ;                                               lattice_16_b    - Channel B, 16th order
    1953            ;
    1954            ; C-code sets the following values:
    1955            ;
    1956            ;       _func_addr_a    =       address of Ch A function
    1957            ;       _func_addr_b    =       address of Ch B function
    1958            ;
    1959            ;       _coef_ptr_b             =       points to first filter coeficient  Ch B (in B1: 300h):
    1960            ;       _data_ptr_b             =       points to first used state address Ch B (in B1: 37fh)
    1961            ;       _coef_ptr_a             =       points to first filter coeficient  Ch A (in B1: 380h):
    1962            ;       _data_ptr_a             =       points to first used state address Ch A (in B1: 3ffh)
    1963            ;
    1964            ;
    1965            ; 300h  _coef_ptr_b:    c(N)    - Ch B, section N
    1966            ;                                               k(N)
    1967            ;                                               d(N)
    1968            ;                                               k(N)    (copy)
    1969            ;                                               c(N-1)  - Ch B, section N-1
    1970            ;                                               k(N-1)
    1971            ;                                               d(N-1)
    1972            ;                                               k(N-1)  (copy)
    1973            ;                                               ...           
    1974            ;                                               c(1)  - Ch B, section 1
    1975            ;                                               k(1)
    1976            ;                                               d(1)
    1977            ;                                               k(1)    (copy)
    1978            ;
    1979            ;                                               v(1)  - Ch B, moving average part
    1980            ;                                               v(2)
    1981            ;                                               ...
    1982            ;                                               v(N+1)
    1983            ;
    1984            ;                                               ... (coef and data grow towards each other)
    1985            ;                                               state(N-1)      - Ch B, section N-1
    1986            ;                                               state(N)        - Ch B, section N
    1987            ; 37fh  _data_ptr_b:    state(N+1)      - Ch B, memory location for allpass output
    1988            ;
    1989            ;
    1990            ; 380h  _coef_ptr_a:    c(N)    - Ch A, section N
    1991            ;                                               k(N)
    1992            ;                                               d(N)
    1993            ;                                               k(N)    (copy)
    1994            ;                                               c(N-1)  - Ch A, section N-1
    1995            ;                                               k(N-1)
    1996            ;                                               d(N-1)
    1997            ;                                               k(N-1)  (copy)
    1998            ;                                               ...           
    1999            ;                                               c(1)  - Ch A, section 1
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   40

    2000            ;                                               k(1)
    2001            ;                                               d(1)
    2002            ;                                               k(1)    (copy)
    2003            ;
    2004            ;                                               v(1)  - Ch A, moving average part
    2005            ;                                               v(2)
    2006            ;                                               ...
    2007            ;                                               v(N+1)
    2008            ;
    2009            ;                                               ... (coef and data grow towards each other)
    2010            ;                                               state(N-1)      - Ch A, section N-1
    2011            ;                                               state(N)        - Ch A, section N
    2012            ; 3ffh  _data_ptr_a:    state(N+1)      - Ch A, memory location for allpass output
    2013            ;
    2014            ;
    2015            ; Coeficent values are stored = int[(2^15)*true_coef_value]
    2016            ;                                                         =     int[32768*true_coef_value]
    2017            ;
    2018            ;**********************************************************************
    2019                            .global _lattice_2_a    ; declare function as global so c-code can find it
    2020            _lattice_2_a:   ; Ch A, 2nd order filter:
    2021            
    2022                            spm             1                       ; set product mode (PM) to 1
    2023                            lar             AR2, _coef_ptr_a ; point to first coef address
    2024                            lar             AR0, _data_ptr_a ; point to state data location N+1
    2025                            mar             *,AR2           ; AR2 -> ARP (point to coefs)
    2026                            
    2027                    ; Section N=2:
    2028                    ; Forward:              
    2029                            lacl    #0                      ; 0 -> ACC
    2030                            lt              _in_a           ; _in_a -> T
    2031                            mpy             *+,AR0          ; T*c2 -> P
    2032                            sbrk    1                       ; AR0-1 -> AR0 (point to state2)
    2033                            lt              *+,AR2          ; state2 -> T
    2034                            mpya    *+                      ; ACC+P -> ACC, T*k2 -> P
    2035                            spac                            ; ACC-P -> ACC
    2036                            sach    temp            ; ACC -> temp
    2037                    ; Backward:
    2038                            lacl    #0                      ; 0 -> ACC
    2039                            mpy             *+                      ; T*d2 -> P
    2040                            lt              _in_a           ; _in_a -> T
    2041                            mpya    *+,AR0          ; ACC+P -> ACC, T*k2 -> P
    2042                            apac                            ; ACC+P -> ACC
    2043                            sach    *-,AR2          ; ACC -> state3
    2044            
    2045                    ; Section N-1=1:
    2046                    ; Forward:              
    2047                            lacl    #0                      ; 0 -> ACC
    2048                            lt              temp            ; temp -> T
    2049                            mpy             *+,AR0          ; T*c1 -> P
    2050                            sbrk    1                       ; AR0-1 -> AR0 (point to state1)
    2051                            lt              *+,AR2          ; state1 -> T
    2052                            mpya    *+                      ; ACC+P -> ACC, T*k1 -> P
    2053                            spac                            ; ACC-P -> ACC
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   41

    2054                            sach    _out_a          ; ACC -> temp2(_out_a)
    2055                    ; Backward:
    2056                            lacl    #0                      ; 0 -> ACC
    2057                            mpy             *+                      ; T*d1 -> P
    2058                            lt              temp            ; temp -> T
    2059                            mpya    *+,AR0          ; ACC+P -> ACC, T*k1 -> P
    2060                            apac                            ; ACC+P -> ACC
    2061                            sach    *-                      ; ACC -> state2
    2062            
    2063                    ; Feedback:
    2064                            lacl    _out_a          ; temp2(_out_a) -> ACC
    2065                            sacl    *                       ; ACC -> state1
    2066            
    2067                    ; Output allpass part for testing: 
    2068            ;               adrk    2                       ; AR0+2 -> AR0 (point to state3)
    2069            ;               lacl    *                       ; state3 -> ACC
    2070            ;               sacl    _out_a          ; ACC -> out
    2071                            
    2072                    ; Compute moving average part of filter:
    2073                            lacl    #0                      ; 0 -> ACC
    2074                            lt              *+,AR2          ; state1 -> T
    2075                            mpy             *+,AR0          ; T*v1 -> P
    2076                            lta             *+,AR2          ; state2 -> T, ACC+P -> ACC
    2077                            mpy             *+,AR0          ; T*v2 -> P
    2078                            lta             *+,AR2          ; state3 -> T, ACC+P -> ACC
    2079                            mpy             *+,AR0          ; T*v3 -> P
    2080                            apac                            ; ACC+P -> ACC
    2081                            sach    _out_a          ; ACC -> out
    2082            
    2083            ; End of Ch A
    2084                            lacl    _func_addr_b    ; get the current B function address ...
    2085                            bacc                                    ; and branch to it
    2086            
    2087            ;**********************************************************************
    2088                            .global _lattice_2_b    ; declare function as global so c-code can find it
    2089            _lattice_2_b:   ; Ch B, 2nd order filter:
    2090            
    2091            ; Start of Ch B
    2092                            lacl    _in_b           ; Ch B in -> ACC
    2093                            bit             _assembly_flag, 13      ; cascade_flag -> TC
    2094                            bcnd    lattice_2_skip,NTC      ; skip cascade hold if flag not set
    2095                            lacl    _out_a          ; Ch A out -> ACC
    2096            lattice_2_skip:
    2097                            sacl    _out_b          ; ACC -> input(_out_b)
    2098            
    2099                            spm             1                       ; set product mode (PM) to 1
    2100                            lar             AR2, _coef_ptr_b ; point to first coef address
    2101                            lar             AR0, _data_ptr_b ; point to state data location N+1
    2102                            mar             *,AR2           ; AR2 -> ARP (point to coefs)
    2103                            
    2104                    ; Section N=2:
    2105                    ; Forward:              
    2106                            lacl    #0                      ; 0 -> ACC
    2107                            lt              _out_b          ; input(_out_b) -> T
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   42

    2108                            mpy             *+,AR0          ; T*c2 -> P
    2109                            sbrk    1                       ; AR0-1 -> AR0 (point to state2)
    2110                            lt              *+,AR2          ; state2 -> T
    2111                            mpya    *+                      ; ACC+P -> ACC, T*k2 -> P
    2112                            spac                            ; ACC-P -> ACC
    2113                            sach    temp            ; ACC -> temp
    2114                    ; Backward:
    2115                            lacl    #0                      ; 0 -> ACC
    2116                            mpy             *+                      ; T*d2 -> P
    2117                            lt              _out_b          ; input(_out_b) -> T
    2118                            mpya    *+,AR0          ; ACC+P -> ACC, T*k2 -> P
    2119                            apac                            ; ACC+P -> ACC
    2120                            sach    *-,AR2          ; ACC -> state3
    2121            
    2122                    ; Section N-1=1:
    2123                    ; Forward:              
    2124                            lacl    #0                      ; 0 -> ACC
    2125                            lt              temp            ; temp -> T
    2126                            mpy             *+,AR0          ; T*c1 -> P
    2127                            sbrk    1                       ; AR0-1 -> AR0 (point to state1)
    2128                            lt              *+,AR2          ; state1 -> T
    2129                            mpya    *+                      ; ACC+P -> ACC, T*k1 -> P
    2130                            spac                            ; ACC-P -> ACC
    2131                            sach    _out_b          ; ACC -> temp2(_out_b)
    2132                    ; Backward:
    2133                            lacl    #0                      ; 0 -> ACC
    2134                            mpy             *+                      ; T*d1 -> P
    2135                            lt              temp            ; temp -> T
    2136                            mpya    *+,AR0          ; ACC+P -> ACC, T*k1 -> P
    2137                            apac                            ; ACC+P -> ACC
    2138                            sach    *-                      ; ACC -> state2
    2139            
    2140                    ; Feedback:
    2141                            lacl    _out_b          ; temp2(_out_b) -> ACC
    2142                            sacl    *                       ; ACC -> state1
    2143            
    2144                    ; Output allpass part for testing: 
    2145            ;               adrk    2                       ; AR0+2 -> AR0 (point to state3)
    2146            ;               lacl    *                       ; state3 -> ACC
    2147            ;               sacl    _out_b          ; ACC -> out
    2148                            
    2149                    ; Compute moving average part of filter:
    2150                            lacl    #0                      ; 0 -> ACC
    2151                            lt              *+,AR2          ; state1 -> T
    2152                            mpy             *+,AR0          ; T*v1 -> P
    2153                            lta             *+,AR2          ; state2 -> T, ACC+P -> ACC
    2154                            mpy             *+,AR0          ; T*v2 -> P
    2155                            lta             *+,AR2          ; state3 -> T, ACC+P -> ACC
    2156                            mpy             *+,AR0          ; T*v3 -> P
    2157                            apac                            ; ACC+P -> ACC
    2158                            sach    _out_b          ; ACC -> out
    2159            
    2160                            ret
    2161                            
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   43

    2162            ;**********************************************************************
    2163                            .global _lattice_4_a    ; declare function as global so c-code can find it
    2164            _lattice_4_a:   ; Ch A, 4th order filter:
    2165            
    2166                            spm             1                       ; set product mode (PM) to 1
    2167                            lar             AR2, _coef_ptr_a ; point to first coef address
    2168                            lar             AR0, _data_ptr_a ; point to state data location N+1
    2169                            mar             *,AR2           ; AR2 -> ARP (point to coefs)
    2170                            
    2171                    ; Section N=4:
    2172                    ; Forward:              
    2173                            lacl    #0                      ; 0 -> ACC
    2174                            lt              _in_a           ; _in_a -> T
    2175                            mpy             *+,AR0          ; T*c4 -> P
    2176                            sbrk    1                       ; AR0-1 -> AR0 (point to state4)
    2177                            lt              *+,AR2          ; state2 -> T
    2178                            mpya    *+                      ; ACC+P -> ACC, T*k4 -> P
    2179                            spac                            ; ACC-P -> ACC
    2180                            sach    temp            ; ACC -> temp
    2181                    ; Backward:
    2182                            lacl    #0                      ; 0 -> ACC
    2183                            mpy             *+                      ; T*d4 -> P
    2184                            lt              _in_a           ; _in_a -> T
    2185                            mpya    *+,AR0          ; ACC+P -> ACC, T*k4 -> P
    2186                            apac                            ; ACC+P -> ACC
    2187                            sach    *-,AR2          ; ACC -> state5
    2188            
    2189                    ; Section i(odd):
    2190                    ; Forward:              
    2191                            lacl    #0                      ; 0 -> ACC
    2192                            lt              temp            ; temp -> T
    2193                            mpy             *+,AR0          ; T*ci -> P
    2194                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2195                            lt              *+,AR2          ; statei -> T
    2196                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2197                            spac                            ; ACC-P -> ACC
    2198                            sach    _out_a          ; ACC -> temp2(_out_a)
    2199                    ; Backward:
    2200                            lacl    #0                      ; 0 -> ACC
    2201                            mpy             *+                      ; T*di -> P
    2202                            lt              temp            ; temp -> T
    2203                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2204                            apac                            ; ACC+P -> ACC
    2205                            sach    *-,AR2          ; ACC -> state(i+1)
    2206            
    2207                    ; Section i(even):
    2208                    ; Forward:              
    2209                            lacl    #0                      ; 0 -> ACC
    2210                            lt              _out_a          ; _out_a -> T
    2211                            mpy             *+,AR0          ; T*ci -> P
    2212                            sbrk    1                       ; AR0-1 -> AR0 (point to state1)
    2213                            lt              *+,AR2          ; state1 -> T
    2214                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2215                            spac                            ; ACC-P -> ACC
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   44

    2216                            sach    temp            ; ACC -> temp
    2217                    ; Backward:
    2218                            lacl    #0                      ; 0 -> ACC
    2219                            mpy             *+                      ; T*di -> P
    2220                            lt              _out_a          ; _out_a -> T
    2221                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2222                            apac                            ; ACC+P -> ACC
    2223                            sach    *-,AR2          ; ACC -> state(i+1)
    2224            
    2225                    ; Section 1:
    2226                    ; Forward:              
    2227                            lacl    #0                      ; 0 -> ACC
    2228                            lt              temp            ; temp -> T
    2229                            mpy             *+,AR0          ; T*c1 -> P
    2230                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2231                            lt              *+,AR2          ; statei -> T
    2232                            mpya    *+                      ; ACC+P -> ACC, T*k1 -> P
    2233                            spac                            ; ACC-P -> ACC
    2234                            sach    _out_a          ; ACC -> temp2(_out_a)
    2235                    ; Backward:
    2236                            lacl    #0                      ; 0 -> ACC
    2237                            mpy             *+                      ; T*d1 -> P
    2238                            lt              temp            ; temp -> T
    2239                            mpya    *+,AR0          ; ACC+P -> ACC, T*k1 -> P
    2240                            apac                            ; ACC+P -> ACC
    2241                            sach    *-                      ; ACC -> state2
    2242            
    2243                    ; Feedback:
    2244                            lacl    _out_a          ; temp2(_out_a) -> ACC
    2245                            sacl    *                       ; ACC -> state1
    2246            
    2247                    ; Output allpass part for testing: 
    2248            ;               adrk    4                       ; AR0+4 -> AR0 (point to state5)
    2249            ;               lacl    *                       ; state5 -> ACC
    2250            ;               sacl    _out_a          ; ACC -> out
    2251                            
    2252                    ; Compute moving average part of filter:
    2253                            lacl    #0                      ; 0 -> ACC
    2254                            lt              *+,AR2          ; state1 -> T
    2255                            mpy             *+,AR0          ; T*v1 -> P
    2256                            lta             *+,AR2          ; state2 -> T, ACC+P -> ACC
    2257                            mpy             *+,AR0          ; T*v2 -> P
    2258                            lta             *+,AR2          ; state3 -> T, ACC+P -> ACC
    2259                            mpy             *+,AR0          ; T*v3 -> P
    2260                            lta             *+,AR2          ; state4 -> T, ACC+P -> ACC
    2261                            mpy             *+,AR0          ; T*v4 -> P
    2262                            lta             *+,AR2          ; state5 -> T, ACC+P -> ACC
    2263                            mpy             *+,AR0          ; T*v5 -> P
    2264                            apac                            ; ACC+P -> ACC
    2265                            sach    _out_a          ; ACC -> out
    2266            
    2267            ; End of Ch A
    2268                            lacl    _func_addr_b    ; get the current B function address ...
    2269                            bacc                                    ; and branch to it
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   45

    2270            
    2271            ;**********************************************************************
    2272                            .global _lattice_4_b    ; declare function as global so c-code can find it
    2273            _lattice_4_b:   ; Ch B, 4th order filter:
    2274            
    2275            ; Start of Ch B
    2276                            lacl    _in_b           ; Ch B in -> ACC
    2277                            bit             _assembly_flag, 13      ; cascade_flag -> TC
    2278                            bcnd    lattice_4_skip,NTC      ; skip cascade hold if flag not set
    2279                            lacl    _out_a          ; Ch A out -> ACC
    2280            lattice_4_skip:
    2281                            sacl    _out_b          ; ACC -> input(_out_b)
    2282            
    2283                            spm             1                       ; set product mode (PM) to 1
    2284                            lar             AR2, _coef_ptr_b ; point to first coef address
    2285                            lar             AR0, _data_ptr_b ; point to state data location N+1
    2286                            mar             *,AR2           ; AR2 -> ARP (point to coefs)
    2287                            
    2288                    ; Section N=4:
    2289                    ; Forward:              
    2290                            lacl    #0                      ; 0 -> ACC
    2291                            lt              _out_b          ; input(_out_b) -> T
    2292                            mpy             *+,AR0          ; T*c4 -> P
    2293                            sbrk    1                       ; AR0-1 -> AR0 (point to state2)
    2294                            lt              *+,AR2          ; state2 -> T
    2295                            mpya    *+                      ; ACC+P -> ACC, T*k4 -> P
    2296                            spac                            ; ACC-P -> ACC
    2297                            sach    temp            ; ACC -> temp
    2298                    ; Backward:
    2299                            lacl    #0                      ; 0 -> ACC
    2300                            mpy             *+                      ; T*d4 -> P
    2301                            lt              _out_b          ; input(_out_b) -> T
    2302                            mpya    *+,AR0          ; ACC+P -> ACC, T*k4 -> P
    2303                            apac                            ; ACC+P -> ACC
    2304                            sach    *-,AR2          ; ACC -> state5
    2305            
    2306                    ; Section i(odd):
    2307                    ; Forward:              
    2308                            lacl    #0                      ; 0 -> ACC
    2309                            lt              temp            ; temp -> T
    2310                            mpy             *+,AR0          ; T*ci -> P
    2311                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2312                            lt              *+,AR2          ; statei -> T
    2313                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2314                            spac                            ; ACC-P -> ACC
    2315                            sach    _out_b          ; ACC -> temp2(_out_b)
    2316                    ; Backward:
    2317                            lacl    #0                      ; 0 -> ACC
    2318                            mpy             *+                      ; T*di -> P
    2319                            lt              temp            ; temp -> T
    2320                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2321                            apac                            ; ACC+P -> ACC
    2322                            sach    *-,AR2          ; ACC -> state(i+1)
    2323            
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   46

    2324                    ; Section i(even):
    2325                    ; Forward:              
    2326                            lacl    #0                      ; 0 -> ACC
    2327                            lt              _out_b          ; _out_b -> T
    2328                            mpy             *+,AR0          ; T*ci -> P
    2329                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2330                            lt              *+,AR2          ; statei -> T
    2331                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2332                            spac                            ; ACC-P -> ACC
    2333                            sach    temp            ; ACC -> temp
    2334                    ; Backward:
    2335                            lacl    #0                      ; 0 -> ACC
    2336                            mpy             *+                      ; T*di -> P
    2337                            lt              _out_b          ; _out_b -> T
    2338                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2339                            apac                            ; ACC+P -> ACC
    2340                            sach    *-,AR2          ; ACC -> state(i+1)
    2341            
    2342                    ; Section N-1=1:
    2343                    ; Forward:              
    2344                            lacl    #0                      ; 0 -> ACC
    2345                            lt              temp            ; temp -> T
    2346                            mpy             *+,AR0          ; T*c1 -> P
    2347                            sbrk    1                       ; AR0-1 -> AR0 (point to state1)
    2348                            lt              *+,AR2          ; state1 -> T
    2349                            mpya    *+                      ; ACC+P -> ACC, T*k1 -> P
    2350                            spac                            ; ACC-P -> ACC
    2351                            sach    _out_b          ; ACC -> temp2(_out_b)
    2352                    ; Backward:
    2353                            lacl    #0                      ; 0 -> ACC
    2354                            mpy             *+                      ; T*d1 -> P
    2355                            lt              temp            ; temp -> T
    2356                            mpya    *+,AR0          ; ACC+P -> ACC, T*k1 -> P
    2357                            apac                            ; ACC+P -> ACC
    2358                            sach    *-                      ; ACC -> state2
    2359            
    2360                    ; Feedback:
    2361                            lacl    _out_b          ; temp2(_out_b) -> ACC
    2362                            sacl    *                       ; ACC -> state1
    2363            
    2364                    ; Output allpass part for testing: 
    2365            ;               adrk    4                       ; AR0+4 -> AR0 (point to state5)
    2366            ;               lacl    *                       ; state5 -> ACC
    2367            ;               sacl    _out_b          ; ACC -> out
    2368                            
    2369                    ; Compute moving average part of filter:
    2370                            lacl    #0                      ; 0 -> ACC
    2371                            lt              *+,AR2          ; state1 -> T
    2372                            mpy             *+,AR0          ; T*v1 -> P
    2373                            lta             *+,AR2          ; state2 -> T, ACC+P -> ACC
    2374                            mpy             *+,AR0          ; T*v2 -> P
    2375                            lta             *+,AR2          ; state3 -> T, ACC+P -> ACC
    2376                            mpy             *+,AR0          ; T*v3 -> P
    2377                            lta             *+,AR2          ; state4 -> T, ACC+P -> ACC
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   47

    2378                            mpy             *+,AR0          ; T*v4 -> P
    2379                            lta             *+,AR2          ; state5 -> T, ACC+P -> ACC
    2380                            mpy             *+,AR0          ; T*v5 -> P
    2381                            apac                            ; ACC+P -> ACC
    2382                            sach    _out_b          ; ACC -> out
    2383            
    2384                            ret
    2385            
    2386            ;**********************************************************************
    2387                            .global _lattice_8_a    ; declare function as global so c-code can find it
    2388            _lattice_8_a:   ; Ch A, 8th order filter:
    2389            
    2390                            spm             1                       ; set product mode (PM) to 1
    2391                            lar             AR2, _coef_ptr_a ; point to first coef address
    2392                            lar             AR0, _data_ptr_a ; point to state data location N+1
    2393                            mar             *,AR2           ; AR2 -> ARP (point to coefs)
    2394                            
    2395                    ; Section N=8:
    2396                    ; Forward:              
    2397                            lacl    #0                      ; 0 -> ACC
    2398                            lt              _in_a           ; _in_a -> T
    2399                            mpy             *+,AR0          ; T*c8 -> P
    2400                            sbrk    1                       ; AR0-1 -> AR0 (point to state8)
    2401                            lt              *+,AR2          ; state8 -> T
    2402                            mpya    *+                      ; ACC+P -> ACC, T*k8 -> P
    2403                            spac                            ; ACC-P -> ACC
    2404                            sach    temp            ; ACC -> temp
    2405                    ; Backward:
    2406                            lacl    #0                      ; 0 -> ACC
    2407                            mpy             *+                      ; T*d8 -> P
    2408                            lt              _in_a           ; _in_a -> T
    2409                            mpya    *+,AR0          ; ACC+P -> ACC, T*k8 -> P
    2410                            apac                            ; ACC+P -> ACC
    2411                            sach    *-,AR2          ; ACC -> state9
    2412            
    2413                    ; Section i(odd):
    2414                    ; Forward:              
    2415                            lacl    #0                      ; 0 -> ACC
    2416                            lt              temp            ; temp -> T
    2417                            mpy             *+,AR0          ; T*ci -> P
    2418                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2419                            lt              *+,AR2          ; statei -> T
    2420                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2421                            spac                            ; ACC-P -> ACC
    2422                            sach    _out_a          ; ACC -> temp2(_out_a)
    2423                    ; Backward:
    2424                            lacl    #0                      ; 0 -> ACC
    2425                            mpy             *+                      ; T*di -> P
    2426                            lt              temp            ; temp -> T
    2427                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2428                            apac                            ; ACC+P -> ACC
    2429                            sach    *-,AR2          ; ACC -> state(i+1)
    2430            
    2431                    ; Section i(even):
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   48

    2432                    ; Forward:              
    2433                            lacl    #0                      ; 0 -> ACC
    2434                            lt              _out_a          ; _out_a -> T
    2435                            mpy             *+,AR0          ; T*ci -> P
    2436                            sbrk    1                       ; AR0-1 -> AR0 (point to state1)
    2437                            lt              *+,AR2          ; state1 -> T
    2438                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2439                            spac                            ; ACC-P -> ACC
    2440                            sach    temp            ; ACC -> temp
    2441                    ; Backward:
    2442                            lacl    #0                      ; 0 -> ACC
    2443                            mpy             *+                      ; T*di -> P
    2444                            lt              _out_a          ; _out_a -> T
    2445                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2446                            apac                            ; ACC+P -> ACC
    2447                            sach    *-,AR2          ; ACC -> state(i+1)
    2448            
    2449                    ; Section i(odd):
    2450                    ; Forward:              
    2451                            lacl    #0                      ; 0 -> ACC
    2452                            lt              temp            ; temp -> T
    2453                            mpy             *+,AR0          ; T*ci -> P
    2454                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2455                            lt              *+,AR2          ; statei -> T
    2456                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2457                            spac                            ; ACC-P -> ACC
    2458                            sach    _out_a          ; ACC -> temp2(_out_a)
    2459                    ; Backward:
    2460                            lacl    #0                      ; 0 -> ACC
    2461                            mpy             *+                      ; T*di -> P
    2462                            lt              temp            ; temp -> T
    2463                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2464                            apac                            ; ACC+P -> ACC
    2465                            sach    *-,AR2          ; ACC -> state(i+1)
    2466            
    2467                    ; Section i(even):
    2468                    ; Forward:              
    2469                            lacl    #0                      ; 0 -> ACC
    2470                            lt              _out_a          ; _out_a -> T
    2471                            mpy             *+,AR0          ; T*ci -> P
    2472                            sbrk    1                       ; AR0-1 -> AR0 (point to state1)
    2473                            lt              *+,AR2          ; state1 -> T
    2474                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2475                            spac                            ; ACC-P -> ACC
    2476                            sach    temp            ; ACC -> temp
    2477                    ; Backward:
    2478                            lacl    #0                      ; 0 -> ACC
    2479                            mpy             *+                      ; T*di -> P
    2480                            lt              _out_a          ; _out_a -> T
    2481                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2482                            apac                            ; ACC+P -> ACC
    2483                            sach    *-,AR2          ; ACC -> state(i+1)
    2484            
    2485                    ; Section i(odd):
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   49

    2486                    ; Forward:              
    2487                            lacl    #0                      ; 0 -> ACC
    2488                            lt              temp            ; temp -> T
    2489                            mpy             *+,AR0          ; T*ci -> P
    2490                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2491                            lt              *+,AR2          ; statei -> T
    2492                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2493                            spac                            ; ACC-P -> ACC
    2494                            sach    _out_a          ; ACC -> temp2(_out_a)
    2495                    ; Backward:
    2496                            lacl    #0                      ; 0 -> ACC
    2497                            mpy             *+                      ; T*di -> P
    2498                            lt              temp            ; temp -> T
    2499                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2500                            apac                            ; ACC+P -> ACC
    2501                            sach    *-,AR2          ; ACC -> state(i+1)
    2502            
    2503                    ; Section i(even):
    2504                    ; Forward:              
    2505                            lacl    #0                      ; 0 -> ACC
    2506                            lt              _out_a          ; _out_a -> T
    2507                            mpy             *+,AR0          ; T*ci -> P
    2508                            sbrk    1                       ; AR0-1 -> AR0 (point to state1)
    2509                            lt              *+,AR2          ; state1 -> T
    2510                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2511                            spac                            ; ACC-P -> ACC
    2512                            sach    temp            ; ACC -> temp
    2513                    ; Backward:
    2514                            lacl    #0                      ; 0 -> ACC
    2515                            mpy             *+                      ; T*di -> P
    2516                            lt              _out_a          ; _out_a -> T
    2517                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2518                            apac                            ; ACC+P -> ACC
    2519                            sach    *-,AR2          ; ACC -> state(i+1)
    2520            
    2521                    ; Section 1:
    2522                    ; Forward:              
    2523                            lacl    #0                      ; 0 -> ACC
    2524                            lt              temp            ; temp -> T
    2525                            mpy             *+,AR0          ; T*c1 -> P
    2526                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2527                            lt              *+,AR2          ; statei -> T
    2528                            mpya    *+                      ; ACC+P -> ACC, T*k1 -> P
    2529                            spac                            ; ACC-P -> ACC
    2530                            sach    _out_a          ; ACC -> temp2(_out_a)
    2531                    ; Backward:
    2532                            lacl    #0                      ; 0 -> ACC
    2533                            mpy             *+                      ; T*d1 -> P
    2534                            lt              temp            ; temp -> T
    2535                            mpya    *+,AR0          ; ACC+P -> ACC, T*k1 -> P
    2536                            apac                            ; ACC+P -> ACC
    2537                            sach    *-                      ; ACC -> state2
    2538            
    2539                    ; Feedback:
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   50

    2540                            lacl    _out_a          ; temp2(_out_a) -> ACC
    2541                            sacl    *                       ; ACC -> state1
    2542            
    2543                    ; Output allpass part for testing: 
    2544            ;               adrk    8                       ; AR0+8 -> AR0 (point to state9)
    2545            ;               lacl    *                       ; state9 -> ACC
    2546            ;               sacl    _out_a          ; ACC -> out
    2547                            
    2548                    ; Compute moving average part of filter:
    2549                            lacl    #0                      ; 0 -> ACC
    2550                            lt              *+,AR2          ; state1 -> T
    2551                            mpy             *+,AR0          ; T*v1 -> P
    2552                            lta             *+,AR2          ; state2 -> T, ACC+P -> ACC
    2553                            mpy             *+,AR0          ; T*v2 -> P
    2554                            lta             *+,AR2          ; state3 -> T, ACC+P -> ACC
    2555                            mpy             *+,AR0          ; T*v3 -> P
    2556                            lta             *+,AR2          ; state4 -> T, ACC+P -> ACC
    2557                            mpy             *+,AR0          ; T*v4 -> P
    2558                            lta             *+,AR2          ; state5 -> T, ACC+P -> ACC
    2559                            mpy             *+,AR0          ; T*v5 -> P
    2560                            lta             *+,AR2          ; state6 -> T, ACC+P -> ACC
    2561                            mpy             *+,AR0          ; T*v6 -> P
    2562                            lta             *+,AR2          ; state7 -> T, ACC+P -> ACC
    2563                            mpy             *+,AR0          ; T*v7 -> P
    2564                            lta             *+,AR2          ; state8 -> T, ACC+P -> ACC
    2565                            mpy             *+,AR0          ; T*v8 -> P
    2566                            lta             *+,AR2          ; state9 -> T, ACC+P -> ACC
    2567                            mpy             *+,AR0          ; T*v9 -> P
    2568                            apac                            ; ACC+P -> ACC
    2569                            sach    _out_a          ; ACC -> out
    2570            
    2571            ; End of Ch A
    2572                            lacl    _func_addr_b    ; get the current B function address ...
    2573                            bacc                                    ; and branch to it
    2574            
    2575            ;**********************************************************************
    2576                            .global _lattice_8_b    ; declare function as global so c-code can find it
    2577            _lattice_8_b:   ; Ch B, 8th order filter:
    2578            
    2579            ; Start of Ch B
    2580                            lacl    _in_b           ; Ch B in -> ACC
    2581                            bit             _assembly_flag, 13      ; cascade_flag -> TC
    2582                            bcnd    lattice_8_skip,NTC      ; skip cascade hold if flag not set
    2583                            lacl    _out_a          ; Ch A out -> ACC
    2584            lattice_8_skip:
    2585                            sacl    _out_b          ; ACC -> input(_out_b)
    2586            
    2587                            spm             1                       ; set product mode (PM) to 1
    2588                            lar             AR2, _coef_ptr_b ; point to first coef address
    2589                            lar             AR0, _data_ptr_b ; point to state data location N+1
    2590                            mar             *,AR2           ; AR2 -> ARP (point to coefs)
    2591                            
    2592                    ; Section N=8:
    2593                    ; Forward:              
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   51

    2594                            lacl    #0                      ; 0 -> ACC
    2595                            lt              _out_b          ; input(_out_b) -> T
    2596                            mpy             *+,AR0          ; T*c8 -> P
    2597                            sbrk    1                       ; AR0-1 -> AR0 (point to state8)
    2598                            lt              *+,AR2          ; state8 -> T
    2599                            mpya    *+                      ; ACC+P -> ACC, T*k8 -> P
    2600                            spac                            ; ACC-P -> ACC
    2601                            sach    temp            ; ACC -> temp
    2602                    ; Backward:
    2603                            lacl    #0                      ; 0 -> ACC
    2604                            mpy             *+                      ; T*d8 -> P
    2605                            lt              _out_b          ; input(_out_b) -> T
    2606                            mpya    *+,AR0          ; ACC+P -> ACC, T*k8 -> P
    2607                            apac                            ; ACC+P -> ACC
    2608                            sach    *-,AR2          ; ACC -> state9
    2609            
    2610                    ; Section i(odd):
    2611                    ; Forward:              
    2612                            lacl    #0                      ; 0 -> ACC
    2613                            lt              temp            ; temp -> T
    2614                            mpy             *+,AR0          ; T*ci -> P
    2615                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2616                            lt              *+,AR2          ; statei -> T
    2617                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2618                            spac                            ; ACC-P -> ACC
    2619                            sach    _out_b          ; ACC -> temp2(_out_b)
    2620                    ; Backward:
    2621                            lacl    #0                      ; 0 -> ACC
    2622                            mpy             *+                      ; T*di -> P
    2623                            lt              temp            ; temp -> T
    2624                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2625                            apac                            ; ACC+P -> ACC
    2626                            sach    *-,AR2          ; ACC -> state(i+1)
    2627            
    2628                    ; Section i(even):
    2629                    ; Forward:              
    2630                            lacl    #0                      ; 0 -> ACC
    2631                            lt              _out_b          ; _out_b -> T
    2632                            mpy             *+,AR0          ; T*ci -> P
    2633                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2634                            lt              *+,AR2          ; statei -> T
    2635                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2636                            spac                            ; ACC-P -> ACC
    2637                            sach    temp            ; ACC -> temp
    2638                    ; Backward:
    2639                            lacl    #0                      ; 0 -> ACC
    2640                            mpy             *+                      ; T*di -> P
    2641                            lt              _out_b          ; _out_b -> T
    2642                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2643                            apac                            ; ACC+P -> ACC
    2644                            sach    *-,AR2          ; ACC -> state(i+1)
    2645            
    2646                    ; Section i(odd):
    2647                    ; Forward:              
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   52

    2648                            lacl    #0                      ; 0 -> ACC
    2649                            lt              temp            ; temp -> T
    2650                            mpy             *+,AR0          ; T*ci -> P
    2651                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2652                            lt              *+,AR2          ; statei -> T
    2653                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2654                            spac                            ; ACC-P -> ACC
    2655                            sach    _out_b          ; ACC -> temp2(_out_b)
    2656                    ; Backward:
    2657                            lacl    #0                      ; 0 -> ACC
    2658                            mpy             *+                      ; T*di -> P
    2659                            lt              temp            ; temp -> T
    2660                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2661                            apac                            ; ACC+P -> ACC
    2662                            sach    *-,AR2          ; ACC -> state(i+1)
    2663            
    2664                    ; Section i(even):
    2665                    ; Forward:              
    2666                            lacl    #0                      ; 0 -> ACC
    2667                            lt              _out_b          ; _out_b -> T
    2668                            mpy             *+,AR0          ; T*ci -> P
    2669                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2670                            lt              *+,AR2          ; statei -> T
    2671                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2672                            spac                            ; ACC-P -> ACC
    2673                            sach    temp            ; ACC -> temp
    2674                    ; Backward:
    2675                            lacl    #0                      ; 0 -> ACC
    2676                            mpy             *+                      ; T*di -> P
    2677                            lt              _out_b          ; _out_b -> T
    2678                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2679                            apac                            ; ACC+P -> ACC
    2680                            sach    *-,AR2          ; ACC -> state(i+1)
    2681            
    2682                    ; Section i(odd):
    2683                    ; Forward:              
    2684                            lacl    #0                      ; 0 -> ACC
    2685                            lt              temp            ; temp -> T
    2686                            mpy             *+,AR0          ; T*ci -> P
    2687                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2688                            lt              *+,AR2          ; statei -> T
    2689                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2690                            spac                            ; ACC-P -> ACC
    2691                            sach    _out_b          ; ACC -> temp2(_out_b)
    2692                    ; Backward:
    2693                            lacl    #0                      ; 0 -> ACC
    2694                            mpy             *+                      ; T*di -> P
    2695                            lt              temp            ; temp -> T
    2696                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2697                            apac                            ; ACC+P -> ACC
    2698                            sach    *-,AR2          ; ACC -> state(i+1)
    2699            
    2700                    ; Section i(even):
    2701                    ; Forward:              
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   53

    2702                            lacl    #0                      ; 0 -> ACC
    2703                            lt              _out_b          ; _out_b -> T
    2704                            mpy             *+,AR0          ; T*ci -> P
    2705                            sbrk    1                       ; AR0-1 -> AR0 (point to statei)
    2706                            lt              *+,AR2          ; statei -> T
    2707                            mpya    *+                      ; ACC+P -> ACC, T*ki -> P
    2708                            spac                            ; ACC-P -> ACC
    2709                            sach    temp            ; ACC -> temp
    2710                    ; Backward:
    2711                            lacl    #0                      ; 0 -> ACC
    2712                            mpy             *+                      ; T*di -> P
    2713                            lt              _out_b          ; _out_b -> T
    2714                            mpya    *+,AR0          ; ACC+P -> ACC, T*ki -> P
    2715                            apac                            ; ACC+P -> ACC
    2716                            sach    *-,AR2          ; ACC -> state(i+1)
    2717            
    2718                    ; Section N-1=1:
    2719                    ; Forward:              
    2720                            lacl    #0                      ; 0 -> ACC
    2721                            lt              temp            ; temp -> T
    2722                            mpy             *+,AR0          ; T*c1 -> P
    2723                            sbrk    1                       ; AR0-1 -> AR0 (point to state1)
    2724                            lt              *+,AR2          ; state1 -> T
    2725                            mpya    *+                      ; ACC+P -> ACC, T*k1 -> P
    2726                            spac                            ; ACC-P -> ACC
    2727                            sach    _out_b          ; ACC -> temp2(_out_b)
    2728                    ; Backward:
    2729                            lacl    #0                      ; 0 -> ACC
    2730                            mpy             *+                      ; T*d1 -> P
    2731                            lt              temp            ; temp -> T
    2732                            mpya    *+,AR0          ; ACC+P -> ACC, T*k1 -> P
    2733                            apac                            ; ACC+P -> ACC
    2734                            sach    *-                      ; ACC -> state2
    2735            
    2736                    ; Feedback:
    2737                            lacl    _out_b          ; temp2(_out_b) -> ACC
    2738                            sacl    *                       ; ACC -> state1
    2739            
    2740                    ; Output allpass part for testing: 
    2741            ;               adrk    8                       ; AR0+8 -> AR0 (point to state9)
    2742            ;               lacl    *                       ; state9 -> ACC
    2743            ;               sacl    _out_b          ; ACC -> out
    2744                            
    2745                    ; Compute moving average part of filter:
    2746                            lacl    #0                      ; 0 -> ACC
    2747                            lt              *+,AR2          ; state1 -> T
    2748                            mpy             *+,AR0          ; T*v1 -> P
    2749                            lta             *+,AR2          ; state2 -> T, ACC+P -> ACC
    2750                            mpy             *+,AR0          ; T*v2 -> P
    2751                            lta             *+,AR2          ; state3 -> T, ACC+P -> ACC
    2752                            mpy             *+,AR0          ; T*v3 -> P
    2753                            lta             *+,AR2          ; state4 -> T, ACC+P -> ACC
    2754                            mpy             *+,AR0          ; T*v4 -> P
    2755                            lta             *+,AR2          ; state5 -> T, ACC+P -> ACC
TMS320C1x/C2x/C2xx/C5x COFF Assembler Version 6.65  Sun Mar 11 19:36:28 2001
Copyright (c) 1987-1997  Texas Instruments Incorporated 
FILTASM.ASM                                                          PAGE   54

    2756                            mpy             *+,AR0          ; T*v5 -> P
    2757                            lta             *+,AR2          ; state6 -> T, ACC+P -> ACC
    2758                            mpy             *+,AR0          ; T*v6 -> P
    2759                            lta             *+,AR2          ; state7 -> T, ACC+P -> ACC
    2760                            mpy             *+,AR0          ; T*v7 -> P
    2761                            lta             *+,AR2          ; state8 -> T, ACC+P -> ACC
    2762                            mpy             *+,AR0          ; T*v8 -> P
    2763                            lta             *+,AR2          ; state9 -> T, ACC+P -> ACC
    2764                            mpy             *+,AR0          ; T*v9 -> P
    2765                            apac                            ; ACC+P -> ACC
    2766                            sach    _out_b          ; ACC -> out
    2767            
    2768                            ret
    2769            
    2770            
    2771                    .endif

 No Errors,  No Warnings
