/**************************************************************************
 *
 *  Recover.c source file
 *
 *  This c source file is a subset of the Filt.c file and is loaded into
 *  filter module in sectors 4 and 5 where it is booted when the module is
 *  powered up with the switch down.
 *
 *  History:
 *    2/21/98 orignial modified from filt.c - Michael Spencer
 *
 **************************************************************************/

/******* Program Parameters ***********************************************/
#define CURSOR_PERIOD 75        /* cursor flashing period (in multiples of 10ms) */
#define OVERFLOW_STICK 5        /* overload LED stick time (on after overload) (in multiples of 10ms */
                                /* (set between 1 and the CURSOR_PERIOD) */
#define VU_DECAY 6              /* decay time between 3dB decrements of VU Meter (in multiples of 5ms) */
#define SW_DEBOUNCE  2000           /* switch/encoder debounce interval in us (set to ~1000) */
#define SERIAL_BUF_LEN 128          /* length of serial input command buffer (128) (MUST BE POWER OF 2) */
#define FCUT_MIN    600.0/48000.0   /* minimum cutoff freq. for LP and HP (fraction of sampling rate) */
#define FCUT_MAX    19200.0/48000.0 /* maximum cutoff freq. for LP and HP (fraction of sampling rate) */
#define F1_MIN      600.0/48000.0   /* minimum cutoff freq. for LP and HP (fraction of sampling rate) */
#define F1_MAX      18200.0/48000.0 /* maximum cutoff freq. for LP and HP (fraction of sampling rate) */
#define F2_MIN      1600.0/48000.0  /* minimum cutoff freq. for LP and HP (fraction of sampling rate) */
#define F2_MAX      19200.0/48000.0 /* maximum cutoff freq. for LP and HP (fraction of sampling rate) */
#define FWIDTH_MIN  1000.0/48000.0  /* minimum width of BP filter (fraction of sampling rate) */
#define GAIN_MAX    10000           /* maximum gain: 100 */

#define SERIAL_LOC  0x0100      /* location of serial number in code space */
#define XTAL        12.288e6    /* frequency of DSP crystal */
#define FLASH_WAITS 4           /* Number of FLASH memory wait states (7 max.) */
#define IO_WAITS    1           /* Number of I/O wait states (7 max.) */
/*#define CLKOUT1       2.0*XTAL    /* frequency of master DSP clock = (1/cycle time) */
/*#define PSCPERIOD (16.0*1e6)/(CLKOUT1) /* set the period out of the prescaler (in microseconds) */
#define LOG2D4  0.0752574989    /* log10(2)/4 for computing ideal calibration constants */
#define PI  3.14159265359

/***** Include files here *************************************************/
#include    "c203.h"    /* Include useful constants and macros for the TMS320C203 */
#include    <stdlib.h>  /* Include standard library header */
#include    <math.h>    /* Include math library header */
#include    <string.h>  /* Include string function header */
#include    <ctype.h>   /* Include character function header */
#include    <limits.h>  /* define LONG_MIN and LONG_MAX */
#include    "filt.h"    /* define chebshev window for FIR filter design (generated by filt.m) */

/***** Globals ************************************************************/
/********* Globals Variables **********************************************/
unsigned int port0_copy;
int sw_down=0, sw_down_old, sw_pressed=0, sw_released=0; /* used by txrxint_c */
int gray_code=0, gray_code_old, cw=0, ccw=0, testcount=0;
int flash_locked=1; /* lock programming of FLASH memory when set */
int cursor_pos, cursor_flag;
int func_index=0, param_index=0, params_changed=1, write_ptr=0, read_ptr=0, p_state=0;
int vu_ctr_in_a=0, vu_ctr_in_b=0, vu_ctr_out_a=0, vu_ctr_out_b=0;
int max_in_level=20;    /* used to hold calibration constant */
long min_value=LONG_MIN, max_value=LONG_MAX;    /* used to limit min and max values of current parameter */
long p_sn1, p_sn2, p_sum, serial_number, sn_ok_flag;    /* used in the parse function */
unsigned byte_count;            /* used in the parse function */
long check_sum;
unsigned flash_data[0x2000];    /* used to hold data to program the FLASH */
float fsample;  /* current sampling rate in Hz*/
char serial_str[10];    /* serial number string of module (including check sums) */
char serial_in_buf[SERIAL_BUF_LEN]; /* RS-232 serial input buffer */
char parameter_str[17], value_str[17];  /* used by cammand parser to hold incomming command strings */
char vu_chars[]={' ', 8, 9, 10, 11, 12, 13, 14, 15, 'X'};   /* used by vu_update() */
float in_cal_levels_a[16], in_cal_levels_b[16], out_cal_a[32], out_cal_b[32], scale_k_a, scale_k_b;
unsigned gopt_a, gopt_b, aopt_a, aopt_b;    /* optimal CODEC gain and attenuation settings */
unsigned in_a_vu_level=0, in_b_vu_level=0, out_a_vu_level=0, out_b_vu_level=0;

/* Define arrays of string pointers for text menus: */
/* (note: duplicate string constants throughout the program are only stored once!) */
/* Basic function strings: */
char *func_text[]={
    "SetOptions ",
    "AllPass    ",
    "LowPass    ",
    "HighPass   ",
    "BandPass   ",
    "BandStop   ",
    ""
    };
/* Parameter label strings: */
char *samplerate_text[]={
    " 8KHz",
    "48KHz",
    ""
    };
char *autoreverttovu_text[]={
    "N",
    "Y",
    ""
    };
char *master_text[]={
    "No(indep)",
    "Yes(freq)",
    "Yes(all) ",
    ""
    };
char *inputsrc_text[]={
    "Analog ",
    "WtNoise",
    ""
    };
char *get_info_text[]={
    "press  ",
    ""
    };
char *calibrate_text[]={
    "press ",
    ""
    };
char *null_text[]={
    ""
    };
char *type_text[]={
    "ButterWorth",
    "Chebyshev I",
    "ChebyshevII",
    "Eliptic    ",
    "LinearPhase",
    ""
    };

/* Define data-structure array that holds all system parameters: params_all[]
 *
 *  .text   - pointer to parameter-string that is displayed on the LCD.
 *            Imbed numbers in text as follows: ### - int, ###.## -float
 *
 *  For "text  text" display:
 *  .value  - parameter value index 0 to n (n=number of parameter label text strings) 
 *  .flag   - flag bits = 10cd ssss nnnn nnnn
 *  .label  - unsinged integer that points to the first parameter label string pointer
 *
 *  For "text int" and "text float" displays:
 *  .value  - current paramter value (holds psudo float data for floats)
 *  .flag   - flag bits = 00cd ssss llll 0fff
 *  .label  - Not used
 *
 *  where: c =          changed flag bit (signals to main() that this param. changed)
 *         d =          derived parameter bit, set if param. is derived from other params
 *         ssss =       start display position for right hand label text
 *         nnnn nnnn =  number of parameter label text strings for this param
 *         llll =       length of displayed number
 *         fff =        number of fractional digits to display to right of "."
 *                      if fff=0 the number is assumed an interger
 *
 *  note: ssss, nnnn nnnn, llll, and fff are initialized in the initialize() function
 *        based on the text strings entered in the structure definition below.
 *        Only d needs to be intialized in structure definition.
 */

struct pstruct {
  char *text;
  long value;
  unsigned int flag;
  unsigned int label;
  };

struct pstruct params_all[]={
/*  0 */    {"FUNC:",           1, 0, (unsigned int)func_text},
/*  1 */    {"SampleRate:",     1, 0, (unsigned int)samplerate_text},
/*  2 */    {"AutoRevertToVU:", 1, 0, (unsigned int)autoreverttovu_text},
/*  3 */    {"Master:",         0, 0, (unsigned int)master_text},
/*  4 */    {"FullScalIn:##Vpp",20, 0, 0},
/*  5 */    {"InputSrc:",       0, 0, (unsigned int)inputsrc_text},
/*  6 */    {"Get Info:",       0, 0, (unsigned int)get_info_text},
/*  7 */    {"Calibrate:",      0, 0, (unsigned int)calibrate_text},
/*  8 */    {"GainA:  ####.##x",100, 0, 0},
/*  9 */    {"GainB:  ####.##x",100, 0, 0},
/* 10 */    {"Store:  # press ",0, 0, 0},
/* 11 */    {"Recall: # press ",0, 0, 0},
/* 12 */    {"Levels:In  Out  ",0, 0, (unsigned int)null_text},

/* 13 */    {"fcut:    #####Hz",10000, 0, 0},
/* 14 */    {"f1:      #####Hz",5000, 0, 0},
/* 15 */    {"f2:      #####Hz",10000, 0, 0},
/* 16 */    {"fcenter: #####Hz",7500, 0x1000, 0},
/* 17 */    {"fwidth:  #####Hz",5000, 0x1000, 0}
            };

/* Specify parameter subset used by each function:
 * This is an array of pointers to elements of the "params_all[]" data-structure array.
 * (put in order desired on LC Display)
 */
struct pstruct *setoptions[]={
    &params_all[0],
    &params_all[1],
    &params_all[2],
    &params_all[3],
    &params_all[4],
    &params_all[5],
    &params_all[6],
    &params_all[7],
    &params_all[10],
    &params_all[11]
    };

struct pstruct *allpass[]={
    &params_all[0],
    &params_all[8],
    &params_all[9],
    &params_all[10],
    &params_all[11],
    &params_all[12]
    };

struct pstruct *lowpass[]={
    &params_all[0],
    &params_all[13],
    &params_all[8],
    &params_all[9],
    &params_all[10],
    &params_all[11],
    &params_all[12]
    };

struct pstruct *highpass[]={
    &params_all[0],
    &params_all[13],
    &params_all[8],
    &params_all[9],
    &params_all[10],
    &params_all[11],
    &params_all[12]
    };

struct pstruct *bandpass[]={
    &params_all[0],
    &params_all[14],
    &params_all[15],
    &params_all[16],
    &params_all[17],
    &params_all[8],
    &params_all[9],
    &params_all[10],
    &params_all[11],
    &params_all[12]
    };

struct pstruct *bandstop[]={
    &params_all[0],
    &params_all[14],
    &params_all[15],
    &params_all[16],
    &params_all[17],
    &params_all[8],
    &params_all[9],
    &params_all[10],
    &params_all[11],
    &params_all[12]
    };

/* Build final pointer array for access to all parameters:
 * This is an array of pointers to an array of pointers to elements of
 * the "params_all[]" data-structure array (which contains pointers to text strings).
 *
 * For "text  text" display, access as follows:
 *    pointer to parameter text= params[func_index][param_index][0].text
 *    parameter value index =   params[func_index][param_index][0].value
 *    flag value =              params[func_index][param_index][0].flag
 *    pointer to label text = (char*)(*(char*)(params[func_index][param_index][0].label + (parameter value)))
 *
 * For "text int" and "text float" displays, access as follows:
 *    pointer to parameter text= params[func_index][param_index][0].text
 *    parameter value =         params[func_index][param_index][0].value
 *    flag value =              params[func_index][param_index][0].flag
 *
 * (put in desired function order)
 */
struct pstruct **params[]={
    &setoptions[0],
    &allpass[0],
    &lowpass[0],
    &highpass[0],
    &bandpass[0],
    &bandstop[0]
    };

int nfunc = sizeof(params)/sizeof(params[0]);   /* get number of functions */
int nparam[]={                                  /* get number of parameters for each function */
    sizeof(setoptions)/sizeof(setoptions[0]),
    sizeof(allpass)/sizeof(allpass[0]),
    sizeof(lowpass)/sizeof(lowpass[0]),
    sizeof(highpass)/sizeof(highpass[0]),
    sizeof(bandpass)/sizeof(bandpass[0]),
    sizeof(bandstop)/sizeof(bandstop[0])
    };
    
    
/********* Globals pointers used for internal data RAM access: *****/
volatile unsigned int *imr_ptr, *greg_ptr, *ifr_ptr;

/***** External Variables to access assembly variables ********************/
extern int kf80fh, kfff0h;
extern int in_a, in_b, out_a, out_b, t_reg_scale_a, t_reg_scale_b;
extern int in_a_hold, in_b_hold, out_a_hold, out_b_hold;
extern unsigned in_error, in_error_stick, in_digital, out_gain, out_atten, iosr_copy;
extern unsigned func_addr, coef_ptr, data_ptr, data0_ptr_a, data0_ptr_b, orderm2;
extern int coef_data[256], state_data[256];

/********* define I/O port variables **************************************/
ioport  unsigned    port0;      /* I/O port pins IO4-IO11 on module */
ioport  unsigned    portffe8;   /* CLK I/O address */
ioport  unsigned    portffec;   /* ICR I/O address */
ioport  unsigned    portfff0;   /* SDTR I/O address */
ioport  unsigned    portfff1;   /* SSPCR I/O address */
ioport  unsigned    portfff4;   /* ADTR I/O address */
ioport  unsigned    portfff5;   /* ASPCR I/O address */
ioport  unsigned    portfff6;   /* IOSR I/O address */
ioport  unsigned    portfff7;   /* BRD I/O address */
ioport  unsigned    portfff8;   /* TCR I/O address */
ioport  unsigned    portfff9;   /* PRD I/O address */
ioport  unsigned    portfffa;   /* TIM I/O address */
ioport  unsigned    portfffc;   /* WSGR I/O address */

/***** Declare external assembly functions ********************************/
extern void no_func(void);
extern void allpass_func(void);
extern void iir2_4(void);
extern void iir1_4(void);
extern void fir2_15(void);
extern void fir2_16(void);
extern void get_serial();

/***** Function Prototypes ************************************************/
// int memtest(unsigned int start_addr, unsigned int end_addr, unsigned int fill);
void txrxint_c(void);
void inc_dec_mod(int *ptr, int mod);
void add_sub_pow(long *ptr, int pow);
void initialize(void);
void reset_lcd(void);
void update_disp_left(void);
void update_disp_right(int pos);
void disp_text(char *text, int position, int cursor_on);
void disp_num(long num, int position, int width, int nfrac);
void write_lcd_inst(int byte, int wait_usec);
void write_lcd_data(int byte, int wait_usec);
void write_lcd_nibble(int nibble, int wait_usec);
void time_start(void);
int time(void);
void wait(int wait_usec);
void compute_fir(void);
void ideal_fir_lp_hp(float *coefs, float f1);
void ideal_fir_bp_bs(float *coefs, float f1, float f2);

/*========================================================================
 =
 =  main() 
 =
 =========================================================================*/
void main(void) 
{
unsigned int i, j; 
unsigned int temp, temp1, temp2;
long ii,jj;
float ftemp, ftemp1, ftemp2;


initialize(); /* Initialize DSP hardware */


/*         1234567890123456     */
disp_text("RecoveryFirmware", 1, -1);
for(i=0;i<2000;i++) wait(1000); /* wait 2 sec */

disp_text("Send serial cmd ", 1, -1);
for(i=0;i<2000;i++) wait(1000); /* wait 2 sec */

/* update_disp_left();      /* display parameter state */
/* update_disp_right(1); */


/***** Start forground loop: **********************************************/
while(1){   /* Loop here and flash cursor until a parmeter change is detected or */
            /* or untill serial data is received: */
  if(cursor_flag&&(!sw_down)){
    /* disp_text("", cursor_pos, -1);   /* turn cursor off */
  }
  else{
    /* disp_text("", cursor_pos, +1);   /* turn cursor on */
  }
  for(i=0;i<CURSOR_PERIOD;i++){
    time_start();
    while(time()<5000){
      if(write_ptr!=read_ptr){  /* something in serial_in_buf[] */
        parse_command();    /* check if command complete, parse and execute */
      }
    }
  }


}  /* END loop forever */

} /* end main */
/*========================================================================*/


/**************************************************************************
 * parse_command
 * This function reads the serial_in_buf[] from the last read entry to the
 * write_ptr. The characters in the buffer are used to update the command
 * parser state and read the incomming command strings. When a valid command
 * is parsed it is executed.
 *
 **************************************************************************/
void parse_command(void)
{
int i, itemp, cursortemp, execute_flag=0, program_flag=0, prog_err_flag=0;
char ctemp, craw;
unsigned utemp;

portfff5 &= ~0x0200;    /* suspend delta interupts while updating display (disp_xxxx below) */
cursortemp = cursor_pos;        /* save current cursor position */

while(write_ptr!=read_ptr){
/* disp_text("                ", 1, -1); */
  craw = serial_in_buf[read_ptr++]; /* get current character */
  ctemp = tolower(craw);            /* convert to lower case */
  read_ptr &= SERIAL_BUF_LEN-1; /* make shure that read_ptr was incremented modulo SERIAL_BUF_LEN */
/* disp_text(&ctemp, 1, -1); */
  switch(p_state){
  case 0:   /* Start of parse: */
    if(ctemp=='a') p_state = 1;
    break;
  case 1:   /* Received: a */
    if(ctemp=='t') p_state = 2;
    else if(ctemp=='a') p_state = 1;
    else p_state = 0;
    break;
  case 2:   /* Received: at */
    if(ctemp=='a') p_state = 3;
    else if(ctemp=='s') p_state = 5;
    else if(ctemp==' ') p_state = 2;
    else p_state = 0;
    break;
  case 3:   /* Received: at a */
    if(ctemp=='t') p_state = 2;
    else if(ctemp=='l') p_state = 4;
    else p_state = 0;
    break;
  case 4:   /* Received: at al */
    if(ctemp=='l'){
        sn_ok_flag = 1;
        p_state = 20;
      }
    else p_state = 0;
    break;
  case 5:   /* Received: at s */
    if(ctemp=='n') p_state = 6;
    else p_state = 0;
    break;
  case 6:   /* Received: at sn */
    if(ctemp==':') p_state = 7;
    else p_state = 0;
    break;
  case 7:   /* Received: at sn: */
    if(isdigit(ctemp)){
      p_state = 8;
      p_sn1 = (long)(ctemp&0x0f);   /* convert character to number */
    }
    else if(ctemp==' ') p_state = 7;
    else p_state = 0;
    break;
  case 8:   /* Received: at sn:# */
    if(isdigit(ctemp)){
      p_sn1 = 10*p_sn1 + (long)(ctemp&0x0f);    /* convert character to number; next digit */
      p_state = 8;
    }
    else if(ctemp==' ') p_state = 8;
    else if(ctemp=='-') p_state = 9;
    else if(ctemp==','){
      if(p_sn1==serial_number){
        sn_ok_flag = 1;
        p_state = 20;
      }
      else{
        p_sn1 = 0;
        p_state = 8;
      }
    }
    else{
      /* Modulo decrement read_ptr because current char could be the first char of command: */
      if((read_ptr--)==0){
        read_ptr = SERIAL_BUF_LEN-1;
      }
      if(p_sn1==serial_number){
        sn_ok_flag = 1;
      }
      else{
        sn_ok_flag = 0;
      }
      p_state = 20;
    }
    break;
  case 9:   /* Received: at sn:#- */
    if(isdigit(ctemp)){
      p_state = 10;
      p_sn2 = (long)(ctemp&0x0f);   /* convert character to number */
    }
    else if(ctemp==' ') p_state = 9;
    else p_state = 0;
    break;
  case 10:  /* Received: at sn:#-# */
    if(isdigit(ctemp)){
      p_sn2 = 10*p_sn2 + (long)(ctemp&0x0f);    /* convert character to number; next digit */
      p_state = 10;
    }
    else if(ctemp=='\r') p_state = 0;   /* carrage return */
    else{
      /* Modulo decrement read_ptr because current char could be the first char of command: */
      if((read_ptr--)==0){
        read_ptr = SERIAL_BUF_LEN-1;
      }
      if((p_sn1<=serial_number)&(serial_number<=p_sn2)){    /* if p_sn1 <= serial_number <= p_sn2 */
        sn_ok_flag = 1;
      }
      else{
        sn_ok_flag = 0;
      }
      p_state = 20;
    }
    break;

  case 20:  /* Received valid header and serial number (eg. at sn:132001) */
    if(isalpha(ctemp)){ /* if ctemp is a letter */
      for(i=0;i<17;i++){
        parameter_str[i] = value_str[i] = '\0'; /* clear command strings */
      }
      parameter_str[0] = ctemp; /* load first char of parameter */
      p_state = 21;
    }
    else if(ctemp=='\r') p_state = 0;   /* carrage return */
    else p_state = 20;
    break;
  case 21:  /* Received first letter of parameter, now get rest... */
    if(ctemp=='\r'){    /* carrage return */
      execute_flag = 1;
      p_state = 0;
    }
    else{
      i =  strlen(parameter_str);
      if(i<16){
        parameter_str[i] = ctemp;   /* load next available location with char */
      }
      else{
        p_state = 0;
      }
    }
    if(ctemp==':'){ /* if parameter received */
      if(strncmp(parameter_str, "program:", 8)==0){;    /* if parameter_str == "program:" */
        p_state = 40;
      }
      else if(strncmp(parameter_str, "display:", 8)==0){
        p_state = 23;
      }
      else{
        p_state = 22;
      }
    }
    break;
  case 22:  /* Received all of parameter, now get value... */
    if(ctemp=='\r'){    /* carrage return */
      execute_flag = 1;
      p_state = 0;
    }
    else{
      i =  strlen(value_str);
      if(i<16){
        value_str[i] = ctemp;   /* load next available location with char */
      }
      else{
        p_state = 0;
      }
    }
    break;
  case 23:  /* Received "display:" command, now get value with UPPER or lower cases... */
    if(ctemp=='\r'){    /* carrage return */
      execute_flag = 1;
      p_state = 0;
    }
    else{
      i =  strlen(value_str);
      if(i<16){
        value_str[i] = craw;    /* load next available location with U/l char */
      }
      else{
        p_state = 0;
      }
    }
    break;

  /* Read FLASH programming parameters: */
  case 40:  /* Received "program:" string */
    if(ctemp==' ') p_state = 40;
    else if(ctemp=='s') p_state = 41;
    else p_state = 0;
    break;
  case 41:  /* Received "program: s". */
    if(ctemp==' ') p_state = 41;
    else if(ctemp==':') p_state = 42;
    else p_state = 0;
    break;
  case 42:  /* Received "program: s:" */
    if(isdigit(ctemp)){
      p_sn1 = (long)(ctemp&0x0f);   /* convert character to number */
      p_state = 43;
    }
    else if(ctemp==' ') p_state = 42;
    else p_state = 0;
    break;
  case 43:  /* Received "program: s:#" */
    if(isdigit(ctemp)){
      p_sn1 = 10*p_sn1 + (long)(ctemp&0x0f);    /* convert character to number; next digit */
      p_state = 43;
    }
    else if(ctemp==' ') p_state = 43;
    else if(ctemp=='l') p_state = 44;
    else p_state = 0;
    break;
  case 44:  /* Received "program: s:# l". */
    if(ctemp==' ') p_state = 44;
    else if(ctemp==':') p_state = 45;
    else p_state = 0;
    break;
  case 45:  /* Received "program: s:# l:" */
    if(isdigit(ctemp)){
      p_sn2 = (long)(ctemp&0x0f);   /* convert character to number */
      p_state = 46;
    }
    else if(ctemp==' ') p_state = 45;
    else p_state = 0;
    break;
  case 46:  /* Received "program: s:# l:#" */
    if(isdigit(ctemp)){
      p_sn2 = 10*p_sn2 + (long)(ctemp&0x0f);    /* convert character to number; next digit */
      p_state = 46;
    }
    else if(ctemp==' ') p_state = 46;
    else if(ctemp=='d') p_state = 47;
    else p_state = 0;
    break;
  case 47:  /* Received "program: s:# l:# d". */
    if(ctemp==' ') p_state = 47;
    else if(ctemp==':'){
      /* Check start and stop parameters */
      /* (must start at beginning of a sector and be one sector long max.) */
      if(((p_sn1==0x0000)||(p_sn1==0x2000)||(p_sn1==0x4000)||(p_sn1==0x6000)||
          (p_sn1==0x8000)||(p_sn1==0xa000)||(p_sn1==0xc000)||(p_sn1==0xe000))&&(p_sn2<=0x2000)&&
          (p_sn2>0)){
        func_addr = (unsigned)&no_func;  /* set the function to none to get maximum CPU time */
        disp_text("Recvd    0 Words", 1, -1);
        byte_count = 0;
        check_sum = 0;
        p_state = 48;
      }
      else{
        prog_err_flag = 1;
        p_state = 0;
      }
    }
    else p_state = 0;
    break;
  case 48:  /* Programming parameters valid, now load flash_data array..." */
    if(byte_count<(p_sn2<<1)){
      utemp = byte_count>>1;    /* divide byte_count by 2 */
      if(byte_count&0x0001){    /* if byte count odd */
        flash_data[utemp] = flash_data[utemp] | craw;   /* load odd data into array */
        if(((utemp+1)&0x001f) == 0){
          disp_num((long)(utemp) + 1, 6, 5 ,0); /* periodicaly update "Recvd     Words" */
        }
      }
      else{ /* byte count even */
        flash_data[utemp] = (craw<<8);  /* load even data into MS Byte of array */
      }
      check_sum += craw;                /* compute running sum */
      byte_count++;
    }
    if(byte_count==(p_sn2<<1)){
      disp_num((long)((byte_count-1)>>1) + 1, 6, 5 ,0); /* update final "Recvd     Words" */
      for(i=0;i<1000;i++) wait(1000);   /* wait 1 sec */
      byte_count = 0;
      p_sum = 0;
      p_state = 49;
    }
    break;
  case 49:  /* Received FLASH data, now get transmitted check sum, and verify... */
    if(byte_count<8){   /* receiving check sum */
      if(isdigit(ctemp)){
        p_sum = 10*p_sum + (long)(ctemp&0x0f);  /* convert character to number; next digit */
      }
      else if(ctemp==' ') p_state = 49;
      else{
        prog_err_flag = 1;
        p_state = 0;    /* space or digit expected */
      }
    }
    if((byte_count++) == 7){    /* full check sum received, verify: */
      if(p_sum==check_sum){ /* received check sum == calculated check sum */
        program_flag = 1;   /* set flag to program FLASH */
      }
      else{ /* bad check sum */
        prog_err_flag = 1;
      }
      p_state = 0;
    }
    break;

  default:
    break;
  } /* end switch(p_state) */

/*  disp_text("p_state=         ", 1, -1);
  disp_num(p_state, 10, 2 ,0); */
  
  if(sn_ok_flag && execute_flag){     /* Execute command in parameter_str and value_str (if valid) */
    if(strncmp(parameter_str, "display:", 8)==0){
      disp_text("                ", 1, -1);
      disp_text(value_str, 1, -1);
    }
/*    disp_text("                ", 1, -1);
    disp_text(parameter_str, 1, -1);
    disp_text(value_str, 9, -1); */
    execute_flag = 0;
  }

  if(sn_ok_flag && prog_err_flag){
    disp_text("PARAMETER ERROR ", 1, -1);
    for(i=0;i<2000;i++) wait(1000); /* wait 2 sec */
    disp_text("WRITE ABORTED!  ", 1, -1);
    for(i=0;i<2000;i++) wait(1000); /* wait 2 sec */
    update_disp_left();     /* update display to reflect parameter settings */
    update_disp_right(1);
    params_changed = 1;     /* flag main loop to update DSP (because we changed func_addr above) */
    prog_err_flag = 0;
  }

  if(sn_ok_flag && program_flag){     /* Program FLASH */
/*    disp_text("                ", 1, -1);
    disp_text("start=",-1);
    disp_num(p_sn1,7,2,0);
    disp_text("len=", 10, -1);
    disp_num(p_sn2,14,2,0); */

    disp_text("Programming...  ", 1, -1);
    flash_locked = 0;   /* unlock flash */
    itemp =  prog_flash((unsigned)p_sn1, (unsigned)p_sn2, flash_data, 1);
    switch(itemp){
    case 0:
      disp_text("Sector Prog. OK ", 1, -1);
/*      disp_text("Cycle power!    ", 1, -1); /* fix: send this measage from PC after all sectors programmed */
/*      for(i=0;i<1000;i++) wait(1000); /* wait 1 sec */
      break;
    case 2:
      disp_text("ERASE TIMOUT ERR", 1, -1);
      break;
    case 3:
      disp_text("ERASE VARIFY ERR", 1, -1);
      break;
    case 1:
    case 4:
    case 5:
      disp_text("PROG TIMEOUT ERR", 1, -1);
      break;
    case 6:
      disp_text("CLIPA SHORT ERR ", 1, -1);
      break;
    default:
      break;
    } /* end switch(itemp) */
    for(i=0;i<1000;i++) wait(1000); /* wait 1 sec */
    update_disp_left();     /* update display to reflect parameter settings */
    update_disp_right(1);
    params_changed = 1;     /* flag main loop to update DSP (because we changed func_addr above) */
    program_flag = 0;
  }
}   /* end while */

disp_text("", cursortemp, 0);   /* put cursor back */
portfff5 |= 0x0200;     /* re-enable delta interupts */

}


/**************************************************************************
 * txrxint_c
 * This is the c-code part of the interrupt service routine that handles
 * the user input actions on both the RS-232 and switch inputs.
 * 
 * This interrupt is initially
 * handled in assembly so that the sample interrupts can be quickly turned
 * back on so no samples will be missed.
 *
 **************************************************************************/
void txrxint_c(void)
{
int i, j, temp_pos, type, nstart, nlength, nfrac, nlabel;
int delta01, io;
int sum2=0, io0_sum=0, io1_sum=0, io2_sum=0;
long jj;

/***** Get RS-232 Action: *************************************************/
if(iosr_copy&0x6700){   /* a serial receive interrupt occurred */
  if(iosr_copy&0x4000){ /* an A Detect Complete interrupt occurred */
    portfff5 &= ~ASPCR_CAD; /* reset the "calibrate a detect" (CAD) bit in the ASPCR*/
/* portfff7 = 0x0001; */
    portfff6 = 0x4000;  /* reset the "a detect complete" (ADC) bit in the IOSR */
  }
  if(iosr_copy&0x0100){ /* a serial Data Ready interrupt occurred */
    serial_in_buf[write_ptr++] = portfff4;  /* read the serial data ADTR */
                                            /* this also resets the DR bit in the IOSR */
    write_ptr &= SERIAL_BUF_LEN-1;  /* make shure that write_ptr was incremented mod SERIAL_BUF_LEN */
    if(write_ptr==read_ptr){    /* Buffer was just overwritten */
      disp_text("BUFFER OVERFLOW!", 1, -1);
      for(i=0;i<1000;i++) wait(1000);   /* wait 1 sec */
      disp_text("Reduce Baud Rate", 1, -1);
      for(i=0;i<1000;i++) wait(1000);   /* wait 1 sec */
    }
  }

  if(iosr_copy&0x2000){ /* a Break Interrupt occurred */
    portfff6 = 0x2000;  /* reset the BI bit in the IOSR */
  }
  if(iosr_copy&0x0400){ /* a Framing Error interrupt occurred */
    portfff6 = 0x0400;  /* reset the FE bit in the IOSR */
  }
  if(iosr_copy&0x0200){ /* a Receive Overrun Error interrupt occurred */
    portfff6 = 0x0200;  /* reset the OE bit in the IOSR */
  }
}


/***** Get Switch Action: *************************************************/
if(iosr_copy&0x00f0){   /* a delta (I/O pin state change) inturrupt occurred */
  /***** Set appropriate SW Action flags (sw_pressed, sw_released, cw, ccw): */
  delta01 = 0x0030&iosr_copy;           /* get delta IO0,1 bits */
  if(0x0010==delta01){              /* quick return if only input 0 changed */
    return;
  }

  io = iosr_copy;
  time_start();
  while(time()<SW_DEBOUNCE){    /* accumulate sw states over debounce interval (~1000uS) */
  /* while(sum<100){ */
    io0_sum += 0x0001&io;       /* do runing sum of IO0 */
    io1_sum += 0x0001&(io>>1);  /* do runing sum of IO1 */
    io2_sum += 0x0001&(io>>2);  /* do runing sum of IO2 */
    io = portfff6;              /* read iosr */
    sum2++;
  }
  sum2 = sum2>>1;   /* divide sum by 2 */

  /* Update Switch and Rotory-Encoder Action parameters: */
  sw_down_old = sw_down;            /* keep sw_down history */
  sw_down = io2_sum<sum2;           /* get inverse of IO2, switch input bit */
  if(sw_down&&(!sw_down_old)){  /* determine if sw pressed or released based on states */
    sw_pressed = 1;
  }
  if((!sw_down)&&sw_down_old){
    sw_released = 1;
  }

  gray_code_old = gray_code; 
  gray_code = ((io1_sum>sum2)<<1)|(io0_sum>sum2);   /* get code for Rotory Encoder (0,1,3,2) */
  switch((gray_code_old<<2)|gray_code){
  case 3:       /* for fast spinning */
  case 12:  /* for fast spinning */
  case 7:
  case 8:
  case 0:       /* for start up */
    ccw = 1;
    break;
  case 6:       /* for fast spinning */
  case 9:       /* for fast spinning */
  case 2:
  case 13:
  case 1:       /* for start up */
    cw = 1;
    break;
  }
  /***** Done seting SW Action flags (sw_down, sw_pressed, sw_released, cw, ccw) *******/

  #if(0)
  if(sw_pressed){
    disp_text("SW pressed    ", 3, -1);
    testcount = 0;
  }
  if(sw_released){
    disp_text("SW released   ", 3, -1);
    testcount = 0;
  }  

  if(sw_down&&(0x0020&delta01)){
    disp_text(" ccw=  cw=", 2, -1);
    disp_num(ccw,7,1,0);
    disp_num(cw,12,1,0);
  }
  
  if(cw) testcount++;
  if(ccw) testcount--;
  disp_num(testcount,10,6,2);
  disp_text("", 15, -1);        /* cursor to position 15 and turn on */
  #endif


  /****** Update display and parameters in response to SW actions: *************/

  type = params[func_index][param_index][0].flag>>15;
  nstart = (0x000f&(params[func_index][param_index][0].flag>>8)) + 1;
  if(type){ /* display type: "text text" */
    nlength = 1;
    nfrac = 0;
  }
  else{
    nlength = 0x000f&(params[func_index][param_index][0].flag>>4);
    nfrac = 0x0007&params[func_index][param_index][0].flag;
  }
  
  if(sw_pressed||(sw_down&&cw)){ /* | || ? */
    /* Increment cursor_pos to next valid position: */
    temp_pos = cursor_pos;
    if(temp_pos==1){
      temp_pos = nstart;
    }
    else{
      ++temp_pos;
      if(temp_pos>=(nstart+nlength)){
        temp_pos = 1;
      }
      else if(nfrac&&(temp_pos==(nstart+nlength-nfrac-1))){ /* float with cursor on decimal point */
        ++temp_pos;
      }
    }
    disp_text("",temp_pos, +1); /* position cursor and turn on */
  } /* end if(sw_pressed||(sw_down&&cw)) */
  else if(sw_down&&ccw){
    /* Decrement cursor_pos to previous valid position: */
    temp_pos = cursor_pos;
    if(temp_pos==1){
      temp_pos = nstart + nlength - 1;
    }
    else{
      --temp_pos;
      if(temp_pos<nstart){
        temp_pos = 1;
      }
      else if(nfrac&&(temp_pos==(nstart+nlength-nfrac-1))){ /* float with cursor on decimal point */
        --temp_pos;
      }
    }
    disp_text("", temp_pos, +1);    /* position cursor and turn on */
  } /* end else if(sw_down&&ccw) */
  else if(cw|ccw){
    if(cursor_pos==1){  /* currsor on left */
      inc_dec_mod(&param_index, nparam[func_index]); /* increment param_index mod nparam[func_index] */
      update_disp_left();       /* write parameter text to LCD left */
      update_disp_right(1); /* write parameter value to LCD right */
    }
    else{       /* currsor on right (somewhere), inc/dec parameter value: */
      if(type){ /* display type: "text text" */ 
        if(param_index){    /* param_index!=0 => pointing to some text parameter */
          nlabel = 0x00ff&params[func_index][param_index][0].flag;      /* get number of labels */
          i = (int)params[func_index][param_index][0].value;
          inc_dec_mod(&i, nlabel);      /* increment .value mod nlabel */
          params[func_index][param_index][0].value = (long)i;
        }
        else{       /* param_index==0 => pointing to function */
          inc_dec_mod(&func_index, nfunc);  /* increment func_index mod nfunc */
          params[func_index][param_index][0].value = (long)func_index;
        }
      }     /* end if (type==1) */
      else{ /* type==0 */
        if(nfrac==0){   /* display type: "text int" */
          i = nstart + nlength - cursor_pos - 1;
        }
        else{           /* display type: "text float" */
          if(cursor_pos>=(nstart + nlength - nfrac)){   /* cursor to right of decimal point */
            i = nstart + nlength - cursor_pos - 1;
          }
          else{
            i = nstart + nlength - cursor_pos - 2;
          }
        }
        /* add/sub 10^i to/from .value: */
        add_sub_pow(&params[func_index][param_index][0].value, i);
      } /* end else type==0 */
      update_disp_right(cursor_pos);    /* write parameter value to LCD right */
    }       /* end else cursor on right (somewhere) */
    params_changed = 1;             /* set change flag */
    params[func_index][param_index][0].flag |= 0x2000;  /* set change bit */
  } /* end else if(cw|ccw) */
  
  
  /* Clear all SW Action flags: */
  sw_pressed = 0;
  sw_released = 0;
  cw = 0;
  ccw = 0;

}   /* end if delta inturrupt */

}   /* return to asmembly and return from interrupt */


/**************************************************************************
 * update_disp_left
 * Updates (writes) the left side of the LCD after striping "#" and "."
 * from the .text string.
 **************************************************************************/
void update_disp_left(void)
{

}

/**************************************************************************
 * update_disp_right
 * Updates (writes) the right side of the LCD with text or a number
 * depending on type.
 * Cursor is put back into pos and turned on prior to retrun.
 **************************************************************************/
void update_disp_right(int pos)
{

}


/**************************************************************************
 * inc_dec_mod
 * Increment/Decrement modulo mod based on cw
 **************************************************************************/
void inc_dec_mod(int *ptr, int mod)
{
if(cw){
  ++(*ptr);
  if((*ptr)>=mod) *ptr = 0;
}
 else{
  --(*ptr);
  if((*ptr)<0) *ptr = mod - 1;
}
}

/**************************************************************************
 * add_sub
 * Add/Subtract 10^pow to long based on cw (where: 0<=pow<=9)
 **************************************************************************/
void add_sub_pow(long *ptr, int pow)
{
long delta;

switch(pow){
case 0:
  delta = 1;
  break;
case 1:
  delta = 10;
  break;
case 2:
  delta = 100;
  break;
case 3:
  delta = 1000;
  break;
case 4:
  delta = 10000;
  break;
case 5:
  delta = 100000;
  break;
case 6:
  delta = 1000000;
  break;
case 7:
  delta = 10000000;
  break;
case 8:
  delta = 100000000;
  break;
case 9:
  delta = 1000000000;
  break;
default:
  delta = 1;
  break;
}

if(cw){
  (*ptr) += delta;
}
 else{
  (*ptr) -= delta;
}

if((*ptr)>max_value){
  (*ptr) = max_value;
}

if((*ptr)<min_value){
  (*ptr) = min_value;
}


}

/**************************************************************************
 *
 *  initialize(): Initialize DSP hardware
 *
 **************************************************************************/

void initialize(void)
{
int i, j, nstart, nlength, nfrac, temp;
char ctemp, carray[7];
unsigned int flag_temp, cursor_temp;
unsigned long jj;

asm("   setc    INTM    ; disable all interrupts    ");
/* asm("    setc    XF      ; Set the CODEC sampling rate to 8 Ksps"); */
asm("   clrc    XF      ; Set the CODEC sampling rate to 48 Ksps");
fsample = 48000.0;
asm("   setc    SXM     ; set sign extension bit (sign-extension on)");
asm("   clrc    CNF     ; map internal memory block B0 into Data space");
asm("   clrc    OVM     ; clear overflow mode bit => normal overflow (assumed by c)");
asm("   spm     0       ; set product shift mode to No Shift (assumed by c)");

/* Initialize assembly language constants and variables: */
kf80fh = 0xf80f;
kfff0h = 0xfff0;
/* MUTE, gainb, gaina: fix*/
out_gain = 0*0x0400 + 0*0x0010 + 0;
/* attenb, attena: */
out_atten = 0*0x0200 + 0*0x0010;
in_a_hold = in_b_hold = out_a_hold = out_b_hold = 0; /* init. VU meter peak hold variables */

optimal_gain();     /* Find and set optimal gain for CODEC input amplifiers */
optimal_atten_a();  /* Find and set optimal attenuation for CODEC output attenuator A */
optimal_atten_b();  /* Find and set optimal attenuation for CODEC output attenuator B */


func_addr = (unsigned)&no_func;  /* set the function to none */
coef_ptr = (unsigned)&coef_data[0]; /* point to begining of coef space (RAM B0) */
data_ptr = (unsigned)&state_data[255]; /* points to address first used of filter state data (RAM B1) */
data0_ptr_a = data_ptr - FIR_LENGTH + 1;
data0_ptr_b = data_ptr - 2*FIR_LENGTH + 1;
orderm2 = FIR_LENGTH - 2;

/* Setup pointers to absolute internal data memory locations: */
imr_ptr = (volatile unsigned int *)4;   /* pointer to IMR (Interrupt Mask Register) */
greg_ptr = (volatile unsigned int *)5;  /* pointer to GREG (Global Memory Allocation Reg) */
ifr_ptr = (volatile unsigned int *)6;   /* pointer to IFR (Interrupt Flag Register) */

*imr_ptr = 0;       /* mask all interrupts */
*ifr_ptr = CLR_ALL; /* clear pending interrupts */
*greg_ptr = 0x0080; /* map flash memory to global data space 0x8000 to 0xffff */ 
portffe8 = 1;       /* CLK: turn off CLKOUT1 DSP pin to reduce noise */
portffec = 0x01c;   /* ICR: (Single-edge MODE, mask INT2) */
/* Set wait states (WSGR): I/O, DATA=0, HiProg=0, LowProg=0 (p. 8-15): */
portfffc = (IO_WAITS*0x0200 + 0*0x0040 + 0*0x0008 + 0);

/* Load the Module's serial number (and check sums) from code memory: */
get_serial(&serial_str);
carray[0] = 0;  /* put null at begining of temp array */
strncat(carray, serial_str, 6); /* get first 6 characters of serial number string */
serial_number = atol(carray);   /* convert to long. FIX: don't use atol, it's a long func. */

/* Initialize Liquid Crystal Display */
port0_copy = 0x0080;        /* Initialize port0 (IO4-11) */
port0 = port0_copy;
reset_lcd();

/* Initialize calibration constants with ideal values fix: don't need? */
for(i=0;i<16;i++){
  in_cal_levels_a[i] = pow(10.0, LOG2D4*i)/8.0;
  in_cal_levels_b[i] = pow(10.0, LOG2D4*i)/8.0;
}
for(i=0;i<32;i++){
  out_cal_a[i] = 7.1*pow(10.0, -LOG2D4*i);
  out_cal_b[i] = 7.1*pow(10.0, -LOG2D4*i);
}

/* Read the Module's parameter structure and write the housekeeping data: */
#define NPARAMS (sizeof params_all)/(sizeof params_all[0])
for(i=0;i<NPARAMS;i++){
/* Search for first '#' or end-of-string and set nstart, nlength and nfrac: */
  nstart = 15;
  nfrac = 0;
  for(j=0;j<=16;j++){
    ctemp = *(params_all[i].text + j);
    if(nstart==15){
      if(ctemp=='#'){
        nstart = j;
        params_all[i].flag &= 0x7fff;   /* clear the text type bit */
      }
      else if(ctemp=='\0'){     /* '#' not found => "text text" type */
        nstart = j;
        params_all[i].flag |= 0x8000;   /* set the text type bit */
        break;
      }
    }
    else{   /* nstart!=15 */  
      if(ctemp=='.'){
        nfrac = j;
      }
      else if(!((ctemp=='#')||(ctemp=='.'))){
        nlength = j - nstart;
        break;
      }
    }
  }
  if(nfrac){
    nfrac = nstart + nlength - nfrac - 1;   /* adjust nfrac to the number of fraction digits */
  }
  if(0x8000&params_all[i].flag){    /* "text text" type */
    j = -1;
    while(*(char*)(*(char*)(params_all[i].label + (++j)))!='\0'){} /* count number entries in label pointer */
    params_all[i].flag = (0xf000&params_all[i].flag)|(nstart<<8)|j; /* load .flag with ssss nnnn nnnn */
  }
  else{                             /* "text int" or "text float" type */
    params_all[i].flag = (0xf000&params_all[i].flag)|(nstart<<8)|(nlength<<4)|nfrac; /* load .flag with ssss llll 0fff */
  }
}   /* end for(i=0;i<NPARAMS;i++) */
func_index = params_all[0].value;   /* initialize func_index as specifed in initialized array */

/* Enable async. port (ASPCR), enable receive and delta interrupts,
   set auto baud-rate detect bit and make IO3 an output: */
portfff5 = 0;       /* make shure port is reset */
portfff6 = 0xfef0;  /* IOSR: reset all bits */
portfff5 = ASPCR_URST;
portfff5 = 0;
/* portfff5 = (ASPCR_URST|ASPCR_DIM|ASPCR_RIM|ASPCR_CAD|ASPCR_CIO3); */
portfff5 = (ASPCR_URST|ASPCR_RIM|ASPCR_CAD|ASPCR_CIO3);
portfff6 = 0xfef0;  /* IOSR: reset all bits */

/* Crystal CS4218 CODEC setup section: */
*ifr_ptr = CLR_ALL; /* clear pending interrupts again */
portfff1 = 0x4300;  /* SSPCR: Put port into reset, int. when FIFO has 4 words */
portfff1 = 0x4330;  /* SSPCR: Take out of reset */
*imr_ptr = EN_RINT|EN_TXRXINT;  /* Unmask Receive interrupt, Unmask SSP  int. */
asm("   clrc    INTM        ; Enable interrupts");

wait(4000000/((long)fsample));  /* wait for ~four sampling intervals for in_error to update */
in_error_stick = 0;         /* reset the sticky bits */


} /* end initialize() */


/**************************************************************************
 * reset_lcd
 *   This function resets the LCD, truns off the cursor and sends it home
 * and loads the CG RAM with bar graph characters.
 *
 **************************************************************************/
void reset_lcd(void)
{
int i, j;

/* Perform SW reset of display (incase hardware reset failed): */
write_lcd_nibble(0x3, 4100);    /* send 4 bit nibble to LCD instruction reg. */
write_lcd_nibble(0x3, 100);     /* send 4 bit nibble to LCD instruction reg. */
write_lcd_nibble(0x3, 100);     /* send 4 bit nibble to LCD instruction reg. */
write_lcd_nibble(0x2, 100);     /* send 4 bit nibble to LCD instruction reg. */

/* Set interface to 4 bits and put the display in known state: */
write_lcd_inst(0x28, 40);       /* Function Set: 4 bit data length, 5x7 dots */
write_lcd_inst(0x0c, 40);       /* Display On, Cursor Off */
cursor_flag = 0;                /* Clear cursor_flag */
write_lcd_inst(0x01, 1640);     /* Clear Display */
write_lcd_inst(0x06, 40);       /* Entry Mode Set: Increment cursor, no shift */
write_lcd_inst(0x02, 1640);     /* Cursor Home */

/* Load thermometer bar code graph into Character Generator RAM: */
write_lcd_inst(0x40, 40);   /* Set Character Generator Address to beginning */
for(i=7;i>=0;i--){
  for(j=1;j<9;j++){
    if(j<=i){
      write_lcd_data(0x00, 40); /* bar off */
    }
    else{
      write_lcd_data(0x0e, 40); /* bar on */
    }
  }
}

write_lcd_inst(0x80, 40);   /* Set Display Data Address to beginning (home) */
cursor_pos = 1;     /* Set global variable to current cursor position */

}

/**************************************************************************
 * disp_text
 *   This function writes a text string to the LCD.
 *
 *   *text      -   Text string to write to LCD display
 *                  (if null string -> cursor put into position)
 *   position   -   1 to 16 - Position of first character
 *                  Final cursor position: one character to the right of the
 *                  end of the string.
 *                  (out-of-limits not checked)
 *  cursor_on   -   Turns on/off curssor:
 *                  +1 - turns on cursor
 *                  -1 - turns off cursor
 *                   0 - cursor visibility not affected
 *
 * Possible speedup: Only update the part of the display that changed.
 *
 *************************************************************************/
void disp_text(char *text, int position, int cursor_on)
{

/* Turn on/off cursor: */
if((cursor_on>0)&&(!cursor_flag)){
  write_lcd_inst(0x0e, 40);     /* turn on cursor */
  cursor_flag = 1;              /* flag cursor on */
}
if((cursor_on<0)&&(cursor_flag)){
  write_lcd_inst(0x0c, 40);     /* turn off cursor */
  cursor_flag = 0;              /* flag cursor off */
}

if(position!=cursor_pos){   /* Put cursor in "position" if not there */
  if(position<9){
    write_lcd_inst((0x80 - 1) + position, 40);
    }
  else{
    write_lcd_inst((0xc0 - 9) + position, 40);
  }
  cursor_pos = position;
}
/* Write characters: */
while(*text!='\0'){ /* loop while not end of string (not null character) */
  write_lcd_data(*text++, 40);
  cursor_pos++;
  if(cursor_pos==9){
    write_lcd_inst(0xc0, 40);/* put the cursor in location 8 */
  }
}
}


 /**************************************************************************
 * disp_num
 *   This function writes a number to the LCD. The number is a long and
 * can appear as an integer: e.g. 123 or as a float: e.g. 32.45
 *
 *   num        -   number to write to LCD display
 *   position   -   1 to 16 - Position of first character (#, -, or space)
 *                  Final cursor position: one character to the right of the
 *                  end of the string
 *                  (out-of-limits not checked)
 *   width      -   Total field width of displed number
 *                  e.g. for num = -26745 (and nfrac=0)
 *                  width=6 -> "-26745"
 *                        7 -> " -26745"
 *                        5 -> "*****"
 *  nfrac       -   number of nfractional digits, number of digits to the right of the
 *                  decimal point.
 *                  e.g. for num = -26745 (and width=7)
 *                  nfrac=0 ->  " -26745"
 *                  nfrac=1 ->  "-2674.5"
 *                  nfrac=5 ->  "-.26745"
 *                  nfrac=6 ->  "-.02674"
 *
 **************************************************************************/
void disp_num(long num, int position, int width, int nfrac)
{
#define BUFLEN 17

char tempc[BUFLEN];
char *bufptr;
int i, wcnt = width, neg = num < 0;
long unum = neg ? -num : num;   /* take absolute value */

/* Convert integer and load array: */
*(bufptr = &tempc[BUFLEN - 1]) = 0; /* put null character at end of charracter array */
do{
  *--bufptr = (unum % 10) + '0';    /* next LS digit, add to code for 0 and store in array */
  wcnt--;
  if((width-wcnt)==nfrac){
    *--bufptr = '.';        /* insert decimal point if fraction */
    wcnt--;
    nfrac = 0;              /* flag fact that decimal point has been inserted */
  }
} while((unum/=10)||nfrac);

/* Insert minus sign if negative: */
if(neg){
  *--bufptr = '-';
  wcnt--;
}
/* Check for field overflow and write "***...**" if overfull: */
if(wcnt<0){
  bufptr = &tempc[BUFLEN - 1];  /* point to last charracter in array */
  for(i=0;i<width;i++){
    *--bufptr = '*';            /* fill with *'s if field overflowed */
  }
}
/* Add leading spaces: */
while((wcnt--)>0){
  *--bufptr = ' ';
}

/* Display text at *bufptr */
disp_text(bufptr, position, 0);
}

/**************************************************************************
 * write_lcd_inst
 *   This function writes a byte into the LCD's instruction register (RS low)
 *
 *   byte       -   input instruction byte
 *   delay_usec -   wait time after instruction write (in micro-seconds)
 *                  valid range: 10 to 32,767 usec
 *                               0 - for minimal delay
 *
 *   This function does not efect the 2 MSBs of port0 (IO10 and IO11).
 **************************************************************************/
void write_lcd_inst(int byte, int wait_usec)
{
int i, iend, nibh, nibl;

nibh = (byte&0xf0)>>4;  /* get high and low nibbles */
nibl = byte&0x0f;

port0_copy = port0_copy&(~0x10);        /* Lower the RS pin */
port0 = port0_copy;

port0_copy = (0xd0&port0_copy)|0x20|nibh; /* Raise E pin on LCD and write low */
port0 = port0_copy;
port0_copy = (0xd0&port0_copy)|nibh;    /* Lower E pin on LCD and hold low */
port0 = port0_copy;

port0_copy = (0xd0&port0_copy)|0x20|nibl; /* Raise E pin on LCD and write high */
port0 = port0_copy;
port0_copy = (0xd0&port0_copy)|nibl;    /* Lower E pin on LCD and hold high */
port0 = port0_copy;

wait(wait_usec);                        /* wait here for LCD not bussy */
}

/**************************************************************************
 * write_lcd_data
 *   This function writes a byte into the LCD's data register (RS high)
 *
 *   byte       -   input data byte
 *   wait_usec -    wait time after data write (in micro-seconds)
 *                  valid range: 10 to 32,767 usec
 *                               0 - for minimal delay
 *
 *   This function does not efect the 2 MSBs of port0 (IO10 and IO11).
 **************************************************************************/
void write_lcd_data(int byte, int wait_usec)
{
int i, iend, nibh, nibl;

nibh = (byte&0xf0)>>4;  /* get high and low nibbles */
nibl = byte&0x0f;

port0_copy = port0_copy|0x10;       /* Raise the RS pin */
port0 = port0_copy;

port0_copy = (0xd0&port0_copy)|0x20|nibh; /* Raise E pin on LCD and write low */
port0 = port0_copy;
port0_copy = (0xd0&port0_copy)|nibh;    /* Lower E pin on LCD and hold low */
port0 = port0_copy;

port0_copy = (0xd0&port0_copy)|0x20|nibl; /* Raise E pin on LCD and write high */
port0 = port0_copy;
port0_copy = (0xd0&port0_copy)|nibl;    /* Lower E pin on LCD and hold high */
port0 = port0_copy;

wait(wait_usec);                        /* wait here for LCD not bussy */
}

/**************************************************************************
 * write_lcd_nibble
 *   This function writes a 4-bit nibble into the LCD's instruction register
 *
 *   nibble     -   input instruction nibble
 *   delay_usec -   wait time after instruction write (in micro-seconds)
 *                  valid range: 10 to 32,767 usec
 *                               0 - for minimal delay
 *
 *   This function does not efect the 2 MSBs of port0 (IO10 and IO11).
 **************************************************************************/
void write_lcd_nibble(int nibble, int wait_usec)
{
int i, iend;

port0_copy = port0_copy&(~0x10);        /* Lower the RS pin */
port0 = port0_copy;

port0_copy = (0xd0&port0_copy)|0x20|nibble; /* Raise E pin on LCD and write */
port0 = port0_copy;
port0_copy = (0xd0&port0_copy)|nibble;  /* Lower E pin on LCD and hold */
port0 = port0_copy;

wait(wait_usec);                        /* wait here for LCD not bussy */
}


/**************************************************************************
 * time_start
 * Restart timer so subsequent calls to time() returns number of micro-seconds
 * since time_start was called.
 *
 **************************************************************************/
void time_start(void)
{

portfff9 = 0xffff;      /* (PRD) set timer period register to start value */
portfff8 = 0x03fc;      /* (TCR) set prescaler for divide by 13 and reload timer */
portfff8 = 0x03cc;      /* (TCR) start timer */
portfff9 = 0x0000;      /* (PRD) set timer reload value to 0 so counter counts */
                        /* down to 0 and stays there */
}

/**************************************************************************
 * time
 * Return time in microseconds since time_start() was called.
 * In this case a microsecond is about 1.058 true microseconds.
 * Returns 0 to 32767. Returns 32767 if more that 32767uS has ellapsed.
 *
 **************************************************************************/
int time(void)
{
int tim;

tim = portfffa;     /* get current running timer value */
/* return (unsigned)(PSCPERIOD*((float)(0xffff-tim)));  /* compute and return ellapsed time */
return (0xffff-tim)>>1; /* compute and return ellapsed time */

}


/**************************************************************************
 * wait
 * Wait for wait_usec microseconds. In this case a microsecond is about
 * 1.0579 true microseconds. Call overhead and ISR's could slightly
 * extend the wait time.
 *
 *                  valid range: 10 to 32,767 usec
 *                               0 - for minimal delay 
 *
 **************************************************************************/
void wait(int wait_usec)
{

time_start();
while(time()<wait_usec);

}


/**************************************************************************
 * prog_flash
 * This function programs the Am29F010 FLASH memory. 32K Bytes of FLASH memory
 * is mapped to the global address space of the DSP starting at address 0x8000.
 * One of four possible blocks of FLASH are mapped to the DSP depending on the
 * IO2 and CLIPA pin levels. 32K Bytes represents two independently erasable FLASH
 * sectors.
 *
 * This function stores 16 bit words in two consecutive FLASH locations
 * with high byte stored first.
 *
 * The FLASH is logically organized into words as follows:
 * Address range        IO2 CLIPA   
 * 0x0000 to 0x1fff     1   0   -   CODE (Main) sector 0 (8K words)(see p. 4-16 Users Guide for required format)
 * 0x2000 to 0x3fff             -   CODE (Main) sector 1 (8K words)
 *
 * 0x4000 to 0x5fff     1   1   -   DATA sector 2 (8K words)
 * 0x6000 to 0x7fff             -   DATA sector 3 (8K words)
 *
 * 0x8000 to 0x9fff     0   0   -   CODE (Backup) sector 4 (8K words) - Boots when button down
 * 0xa000 to 0xbfff             -   CODE (Backup) sector 5 (8K words)
 *
 * 0xc000 to 0xdfff     0   1   -   SPARE sector 7 (8K words)
 * 0xe000 to 0xffff             -   SPARE sector 8 (8K words)
 *
 *  start   -   Starting word location of FLASH storage to program (0 to 0xffff)
 *  length  -   Length in words to program (1 to 0x2000)
 *              (don't span sectors with input range)
 *  datawords - Pointer to data array
 *  erase_flag- 1 - erases (sets to 0xff's) entire sector before programming
 *              0 - programs without erassing (only use if known to be errased)
 *
 *  Returns -   0 - programmed OK
 *              1 - parameter error (or flash_locked = 1)
 *              2 - erase timeout error
 *              3 - erase verify error
 *              4 - programming 0->1 error, must erase first
 *              5 - programming timeout error
 *              6 - programming DATA section error: can't set CLIPA bit
 *
 **************************************************************************/
int prog_flash(unsigned start, unsigned length, unsigned *datawords, int erase_flag)
{
unsigned int i, j, status1, status2, word, byte, xbyte, sector_start;
char ctemp[10];

if(flash_locked){   /* return */
  return 1;
}

if(start<0x4000){       /* set: IO2 = 1 (should be there), CLIPA = 0 */
  out_atten &= ~0x000c; /* clear CLIP LEDs to map FLASH CODE memory (if not) */
}
else if(start<0x8000){  /* set: IO2 = 1 (should be there), CLIPA = 1 */
  start -= 0x4000;
  out_atten |= 0x000c;  /* set CLIP LEDs to map FLASH DATA memory */
}
else if(start<0xc000){  /* set: IO2 = 0, CLIPA = 0 */
  start -= 0x8000;
  portfff5 &= ~0x0200;  /* mask delta interrupts */
  portfff5 |= 0x0004;   /* make IO2 an output */
  portfff6 &= ~0x0004;  /* and clear IO2 */
  out_atten &= ~0x000c; /* clear CLIP LEDs to map FLASH CODE memory (if not) */
}
else{                   /* set: IO2 = 0, CLIPA = 1 */
  start -= 0xc000;
  portfff5 &= ~0x0200;  /* mask delta interrupts */
  portfff5 |= 0x0004;   /* make IO2 an output */
  portfff6 &= ~0x0004;  /* and clear IO2 */
  out_atten |= 0x000c;  /* set CLIP LEDs to map FLASH DATA memory */
}

if(((start<0x2000)&&((start+length)>0x2000))||((start>=0x2000)&&((start+length)>0x4000))){
  flash_locked = 1; /* parameter error, so lock flash and return */
  return 1;
}

wait(4000000/((long)fsample));  /* wait for ~four sampling intervals for CLIP signals to propagate */

*greg_ptr = 0x0080; /* map flash memory to global data space: 0x8000 to 0xffff */ 
portfffc = (IO_WAITS*0x0200 + FLASH_WAITS*0x0040 + 0*0x0008 + 0);   /* Increase # wait states in data mem. */

*((unsigned int *)(0x8000+0x5555)) = 0x00aa;    /* put FLASH into normal read state */
*((unsigned int *)(0x8000+0x2aaa)) = 0x0055;
*((unsigned int *)(0x8000+0x5555)) = 0x00f0;

if(out_atten&0x0008){   /* If CLIPA should be set: */
  /* Verify that CLIPA signal was actualy set by making sure that the FLASH serial number */
  /* is not present in FLASH memory space. This avoids accidently overwriting CODE memory. */

  /* Read serial number section from FLASH: */
  j = 0;
  for(i=(2*SERIAL_LOC)+4;i<(2*SERIAL_LOC)+4+10;i++){
    ctemp[j++] = (*((unsigned int *)(0x8000+i)))&0x00ff;    /* get bytes from FLASH */
  }
  if(valid_serial(ctemp)){  /* if valid serial number  */
    flash_locked=1;
    return 6;
  }
}

if(erase_flag){ /* Erase FLASH sector(s): */
  if(start<0x2000){
    sector_start = 0x0000;
  }
  else{
    sector_start = 0x4000;
  }
  
  /* Erase sector 0 or 1 (depending on sector_start): */
  *((unsigned int *)(0x8000+0x5555)) = 0x00aa;  /* write unlock code to FLASH */
  *((unsigned int *)(0x8000+0x2aaa)) = 0x0055;
  *((unsigned int *)(0x8000+0x5555)) = 0x0080;
  *((unsigned int *)(0x8000+0x5555)) = 0x00aa;
  *((unsigned int *)(0x8000+0x2aaa)) = 0x0055;
  *((unsigned int *)(0x8000+sector_start)) = 0x0030;    /* write command to erase sector 0 */
  wait(100);    /* wait 100 uS */
  do{
    status1 = *((unsigned int *)(0x8000+sector_start)); /* read two consecutive status bytes */
    status2 = *((unsigned int *)(0x8000+sector_start));
    if(((status1&0x0040)==(status2&0x0040))||(status1&0x0080)){ /* no change in DQ6: done toggling */
      goto pf_1;                                                    /* or DQ7==1 */
    }
  }
  while(!(status1&0x00020));    /* loop unless timeout (DQ5==1) */
  status1 = *((unsigned int *)(0x8000+sector_start));   /* read two consecutive status bytes */
  if(status1&0x0080){   /* DQ7==1 */
    goto pf_1;
  }
  *((unsigned int *)(0x8000+0x5555)) = 0x00aa;  /* put FLASH into normal read state */
  *((unsigned int *)(0x8000+0x2aaa)) = 0x0055;
  *((unsigned int *)(0x8000+0x5555)) = 0x00f0;
  flash_locked=1;
  return 2;         /* erase timeout error */
 pf_1:
  *((unsigned int *)(0x8000+0x5555)) = 0x00aa;  /* put FLASH into normal read state */
  *((unsigned int *)(0x8000+0x2aaa)) = 0x0055;
  *((unsigned int *)(0x8000+0x5555)) = 0x00f0;
  /* Varify FLASH erased: */
  for(i=sector_start;i<(0x4000+sector_start);i++){
    if(((*((unsigned int *)(0x8000+i)))&0x00ff)!=0x00ff){
      flash_locked=1;
      return 3;         /* not erased error */
    }
  }
}


/* Program FLASH: */
j = 0;
start = (start<<1);             /* set start to point to the starting word in FLASH */
length = start + (length<<1);   /* set length to last FLASH address + 1 */
for(i=start;i<length;i++){
  if(i&0x0001){ /* i odd */
    byte = word&0x00ff;         /* get LS byte */
  }
  else{     /* i even */
    word = datawords[j++];      /* get current word */
    byte = word>>8;             /* get MS byte */
  }
  *((unsigned int *)(0x8000+0x5555)) = 0x00aa;  /* put FLASH into normal read state */
  *((unsigned int *)(0x8000+0x2aaa)) = 0x0055;
  *((unsigned int *)(0x8000+0x5555)) = 0x00f0;
  xbyte = (*((unsigned int *)(0x8000+i))^byte)&0x00ff;  /* current FLASH byte XOR with desired data */
  if(xbyte){        /* data is different: must reprogram byte */
    if(xbyte&byte){ /* error: can't program 0 bit to 1 bit */
      *((unsigned int *)(0x8000+0x5555)) = 0x00aa;  /* put FLASH into normal read state */
      *((unsigned int *)(0x8000+0x2aaa)) = 0x0055;
      *((unsigned int *)(0x8000+0x5555)) = 0x00f0;
      flash_locked=1;
      return 4;         /* programming 0 to 1 error */
    }
    *((unsigned int *)(0x8000+0x5555)) = 0x00aa;    /* write unlock code to FLASH */
    *((unsigned int *)(0x8000+0x2aaa)) = 0x0055;
    *((unsigned int *)(0x8000+0x5555)) = 0x00a0;
    *((unsigned int *)(0x8000+i)) = byte;   /* program FLASH byte */
    do{ /* !data polling */
      status1 = *((unsigned int *)(0x8000+i));
      status2 = *((unsigned int *)(0x8000+i));
      if(((status1&0x0040)==(status2&0x0040))||((status1&0x0080)==(byte&0x0080))){  /* no change in DQ6 */
        goto pf_3;                                                                  /* or DQ7==DATA7 */
      }
    }
    while(!(status1&0x00020));  /* loop unless timeout (DQ5==1) */
    status1 = *((unsigned int *)(0x8000+i));
    if((status1&0x0080)==(byte&0x0080)){        /* done */
      goto pf_3;
    }
    *((unsigned int *)(0x8000+0x5555)) = 0x00aa;    /* put FLASH into normal read state */
    *((unsigned int *)(0x8000+0x2aaa)) = 0x0055;
    *((unsigned int *)(0x8000+0x5555)) = 0x00f0;
    flash_locked=1;
    return 5;           /* programming timeout error */
  }
  pf_3:
  continue;
}

portfffc = (IO_WAITS*0x0200 + 0*0x0040 + 0*0x0008 + 0); /* back to 0 wait states in data mem. */

portfff5 &= ~0x0004;    /* make IO2 an input (if not) */
wait(400);              /* wait for I02 to go high (4 RC's = 4*10K*0.01uF) */
portfff6 = 0x00ff;      /* clear pending delta interrupts */
portfff5 |= 0x0200;     /* unmask delta interrupts */
out_atten &= ~0x000c;   /* clear CLIP LEDs (if not) */

flash_locked=1;         /* lockout accidental FLASH programming */
return 0;               /* success! */

}


/**************************************************************************
 * read_flash
 * This function reads the Am29F010 FLASH memory. 32K Bytes of FLASH memory
 * is mapped to the global address space of the DSP starting at address 0x8000.
 * This function retrieves 16 bit words from two consecutive FLASH locations
 * with high byte stored first.
 *
 * The FLASH is logically organized into words as follows:
 * Address range        IO2 CLIPA   
 * 0x0000 to 0x1fff     1   0   -   CODE (Main) sector 0 (8K words)(see p. 4-16 Users Guide for required format)
 * 0x2000 to 0x3fff             -   CODE (Main) sector 1 (8K words)
 *
 * 0x4000 to 0x5fff     1   1   -   DATA sector 2 (8K words)
 * 0x6000 to 0x7fff             -   DATA sector 3 (8K words)
 *
 * 0x8000 to 0x9fff     0   0   -   CODE (Backup) sector 4 (8K words) - Boots when button down
 * 0xa000 to 0xbfff             -   CODE (Backup) sector 5 (8K words)
 *
 * 0xc000 to 0xdfff     0   1   -   SPARE sector 7 (8K words)
 * 0xe000 to 0xffff             -   SPARE sector 8 (8K words)
 *
 *  start   -   Starting word location of FLASH storage to retreive (0 to 0xffff)
 *  length  -   Length in words to retreive (1 to 0x2000)
 *              (don't span from 0x3fff-0x4000 (or similar) with input range)
 *  datawords - Pointer to data array
 *
 **************************************************************************/
void read_flash(unsigned start, unsigned length, unsigned *datawords)
{
unsigned int i, j, byte;

if(start<0x4000){       /* set: IO2 = 1 (should be there), CLIPA = 0 */
  out_atten &= ~0x000c; /* clear CLIP LEDs to map FLASH CODE memory (if not) */
}
else if(start<0x8000){  /* set: IO2 = 1 (should be there), CLIPA = 1 */
  start -= 0x4000;
  out_atten |= 0x000c;  /* set CLIP LEDs to map FLASH DATA memory */
}
else if(start<0xc000){  /* set: IO2 = 0, CLIPA = 0 */
  start -= 0x8000;
  portfff5 &= ~0x0200;  /* mask delta interrupts */
  portfff5 |= 0x0004;   /* make IO2 an output */
  portfff6 &= ~0x0004;  /* and clear IO2 */
  out_atten &= ~0x000c; /* clear CLIP LEDs to map FLASH CODE memory (if not) */
}
else{                   /* set: IO2 = 0, CLIPA = 1 */
  start -= 0xc000;
  portfff5 &= ~0x0200;  /* mask delta interrupts */
  portfff5 |= 0x0004;   /* make IO2 an output */
  portfff6 &= ~0x0004;  /* and clear IO2 */
  out_atten |= 0x000c;  /* set CLIP LEDs to map FLASH DATA memory */
}

wait(4000000/((long)fsample));  /* wait for ~four sampling intervals for CLIP signals to propagate */

*greg_ptr = 0x0080; /* map flash memory to global data space: 0x8000 to 0xffff */ 
portfffc = (IO_WAITS*0x0200 + FLASH_WAITS*0x0040 + 0*0x0008 + 0);   /* Increase # wait states in data mem. */

*((unsigned int *)(0x8000+0x5555)) = 0x00aa;    /* put FLASH into normal read state (if should already be there) */
*((unsigned int *)(0x8000+0x2aaa)) = 0x0055;
*((unsigned int *)(0x8000+0x5555)) = 0x00f0;
/* Read FLASH: */
j = 0;
start = (start<<1);             /* set start to point to the starting byte in FLASH */
length = start + (length<<1);   /* set length to last FLASH address + 1 */
for(i=start;i<length;i+=2){
  datawords[j++] = ((*((unsigned int *)(0x8000+i)))<<8) | ((*((unsigned int *)(0x8001+i))&0x00ff)); /* build word */
}

portfffc = (IO_WAITS*0x0200 + 0*0x0040 + 0*0x0008 + 0); /* back to 0 wait states in data mem. */

portfff5 &= ~0x0004;    /* make IO2 an input (if not) */
wait(400);              /* wait for I02 to go high (4 RC's = 4*10K*0.01uF) */
portfff6 = 0x00ff;      /* clear pending delta interrupts */
portfff5 |= 0x0200;     /* unmask delta interrupts */
out_atten &= ~0x000c;   /* clear CLIP LEDs (if not) */

}


/**************************************************************************
 * valid_serial
 * This function returns a 1 if the serial number string is valid
 * and a 0 if not valid.
 *
 * A valid serial number consists of 6 digits followed by 4 check digits:
 *
 *      0123456789
 *      ######oess  -   SN with check sums
 *
 *      ######  -   6 digit SN eg. 132001
 *      o       -   check sum of # # #  (odd digits) modulo 10
 *      e       -   check sum of  # # # (even digits) modulo 10
 *      ss      -   check sum of ######oe
 *
 **************************************************************************/
int valid_serial(char *carray)
{
int i, code, num[10], sumo=0, sume=0, sumss=0;

for(i=0;i<10;i++){
  code = carray[i]; /* get */
  num[i] = code - 0x30; /* convert to decimal and save */
  if((code<0x30)||(code>0x39)){
    return 0;   /* error, not ASCII digit 0 to 9 */
  }
}

sumo = num[0]+num[2]+num[4];
sumo = sumo - (sumo/10)*10;         /* sum = sum modulo 10 */

sume = num[1]+num[3]+num[5];
sume = sume - (sume/10)*10;         /* sum = sum modulo 10 */

sumss = num[0]+num[1]+num[2]+num[3]+num[4]+num[5]+sumo+sume;

if((sumo!=num[6])||(sume!=num[7])||(sumss!=(10*num[8]+num[9]))){
  return 0;     /* checksum error */
}

return 1;       /* checksum OK */
}


/**************************************************************************
 * optimal_gain
 * This function computes the optimal input gain for the CODEC and
 * the scale factor for the VU Meters.
 *
 **************************************************************************/
void optimal_gain(void)
{
float cl, ftemp;

/* Channel A: */
cl = (float)params[0][4][0].value;  /* get FullScalIn value */
for(gopt_a=1;gopt_a<16;gopt_a++){
  ftemp = (16.0*in_cal_levels_a[gopt_a]*cl)/max_in_level;   /* calulate eqs. 8 & 9 in Gain cal. notes */
  if(ftemp>=2.0){
    break;  /* break out of for loop */
  }
}
gopt_a--;
out_gain = (out_gain&(0xff00))|gopt_a;      /* update the CODEC gain A */
scale_k_a = max_in_level/(8.0*in_cal_levels_a[gopt_a]*cl);  /* compute VU Meter scale factor */

/* Channel B: */
cl = (float)params[0][4][0].value;  /* get FullScalIn value */
for(gopt_b=1;gopt_b<16;gopt_b++){
  ftemp = (16.0*in_cal_levels_b[gopt_b]*cl)/max_in_level;   /* calulate eqs. 8 & 9 in Gain cal. notes */
  if(ftemp>=2.0){
    break;  /* break out of for loop */
  }
}
gopt_b--;
out_gain = (out_gain&(0xff00))|(gopt_b<<4);     /* update the CODEC gain B */
scale_k_b = max_in_level/(8.0*in_cal_levels_b[gopt_b]*cl);  /* compute VU Meter scale factor */


}


/**************************************************************************
 * optimal_atten_a
 * This function computes the optimal output attenuation for the CODEC
 * and the gain factor.
 *
 **************************************************************************/
void optimal_atten_a(void)

{
float tgain, tlin, ftemp;
int itemp;

min_value = -GAIN_MAX;  /* set min and max value to bound paramter */
max_value = GAIN_MAX;

/* set GainA: fix: if 256*ftemp > 32767 we must limit max_value*/
tgain = 0.01*params[1][1][0].value; /* get GainA */
tlin = 16.0*in_cal_levels_a[gopt_a]/max_in_level;   /* compute Lin(gopt_a) for calulation below */
ftemp = tgain/(tlin*scale_k_a); /* calulate eq. 13 in Gain cal. notes */
for(aopt_a=1;aopt_a<32;aopt_a++){
  if(out_cal_a[aopt_a]<=fabs(ftemp)){
    break;  /* break out of for loop */
  }
}
aopt_a--;
out_atten = (out_atten&(~0x3ff0))|(aopt_a<<4);  /* update the CODEC attenuation A */
ftemp = tgain/(out_cal_a[aopt_a]*tlin);         /* compute output gain factor */
t_reg_scale_a = (int)(256.0*ftemp + 0.5);       /* convert to scaled integer for use in assembly */

/* itemp = cursor_pos;
disp_num(aopt_a,1,2,0);
disp_num(t_reg_scale_a,3,6,0);
disp_text("", itemp, 0);    /* put cursor back */


}

/**************************************************************************
 * optimal_atten_b
 * This function computes the optimal output attenuation for the CODEC
 * and the gain factor.
 *
 **************************************************************************/
void optimal_atten_b(void)

{
float tgain, tlin, ftemp;
int itemp;

min_value = -GAIN_MAX;  /* set min and max value to bound paramter */
max_value = GAIN_MAX;

/* set GainB: fix: if 256*ftemp > 32767 we must limit max_value*/
tgain = 0.01*params[1][2][0].value; /* get GainB */
tlin = 16.0*in_cal_levels_b[gopt_b]/max_in_level;   /* compute Lin(gopt_b) for calulation below */
ftemp = tgain/(tlin*scale_k_b); /* calulate eq. 13 in Gain cal. notes */
for(aopt_b=1;aopt_b<32;aopt_b++){
  if(out_cal_b[aopt_b]<=fabs(ftemp)){
    break;  /* break out of for loop */
  }
}
aopt_b--;
out_atten = (out_atten&(~0x3ff0))|(aopt_b<<9);  /* update the CODEC attenuation B */
ftemp = tgain/(out_cal_b[aopt_b]*tlin);         /* compute output gain factor */
t_reg_scale_b = (int)(256.0*ftemp + 0.5);       /* convert to scaled integer for use in assembly */

/* itemp = cursor_pos;
disp_num(aopt_b,1,2,0);
disp_num(t_reg_scale_b,3,6,0);
disp_text("", itemp, 0);    /* put cursor back */


}

