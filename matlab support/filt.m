% This program designs a FIR filter window 
% and writes the filt.h header file for the Versa-Filter.

flops(0);

Nfir = 127;     % 3 to 256 Filter length (odd for no zero at fs/2)
fs = 48;        % Sampling rate (in KHz)


%*************************************************************************:
% Design the FIR filter window:
% The DSP uses equ. 7.98 on p.461 in Oppenheim and Schafer to compute the
% truncated ideal inpulse reponse of a multi-band filter.

%window = chebwin(Nfir,r);  % get length Nfir chebychev window
window = blackman(Nfir);
%window = hamming(Nfir);
%window = kaiser(Nfir,10.0);

window = window./sum(window);   % normalize window so DC gain is 1

% Plot response of window:
if(1)
figure
subplot(2,1,1)
plot(window), zoom on
axis([0, Nfir, 0, 0.02])
[H,f] = freqz(window,[1], 8*1024, fs);
subplot(2,1,2)
plot(f,20*log10(abs(H)))
title('Magnitude Response of Blackman Window')
xlabel('Frequency (KHz))')
ylabel('Magnitude Response (dB)')
grid on
zoom on
axis([0, fs/2, -100,10])
%   print c:\work\sps\filter\filtsoft\ideal.eps -deps -tiff
end

wtype = 1;      % optimal window type
lnorm = 20;     % l-norm for optimizer
find_opt = 0;   % find optimal window
if(find_opt)    % Find optimal parameters for window that minimize the sidelobe levels:
  % fpass = 0.90*127/Nfir;  % set the main lobe width
  fpass = 0.019*127/Nfir;   % set the main lobe width
  switch wtype
  case 1    % window is sum of cosines: w = a(1) + a(2)*cos(pi*t) + a(3)*cos(2*pi*t);
    aopt = [.42, -.5, .08]; % start with the Blackman coefs
  case 2    % window is power series: w = a(1) + a(2)*t.^2 + a(3)*t.^4 + a(4)*t.^6 + a(5)*t.^8;
    aopt = [1 0 0 0 0];
  case 3    % window: w = a(1) + a(2)*abs(t).^a(3);
    aopt = [1 0 0];
  end
  aopt = fmins('wincost',aopt,[],[],Nfir,lnorm,fpass,wtype);    % find aopt that minimize wincost
  aopt = fmins('wincost',aopt,[],[],Nfir,lnorm,fpass,wtype);    % restart
else    % use predetermined parameters:
  switch wtype
  case 1    % window is sum of cosines: w = a(1) + a(2)*cos(pi*t) + a(3)*cos(2*pi*t);
    aopt = [.42, -.5, .08]; % start with the Blackman coefs
  case 2    % window is power series: w = a(1) + a(2)*t.^2 + a(3)*t.^4 + a(4)*t.^6 + a(5)*t.^8;
    aopt = [1 0 0 0 0];
  case 3    % window: w = a(1) + a(2)*abs(t).^a(3);
    aopt = [1 0 0];
  end
  
    % From: fpass = 0.85*127/Nfir, |.|^6
    %aopt = [ -2.82565396446698   3.33625910016795  -1.96146734929453   0.36410950684658  0.11582207244760];
%    orders = [2 4 6 8 10];
    % From: fpass = 0.9*127/Nfir, |.|^6
%    aopt = [-3.02516267528867   3.86916964583341  -2.57018413301440   0.74669046798555];
%    orders = [2 4 6 8];
    % From: fpass = 0.5*127/Nfir, |.|^6
    %aopt = [-1.60736278478314   2.28982348965903  -3.59598738112930   2.32443579494662];
%    aopt = [0 0 0 0];
%    orders = [2 4 6 8];
    %orders = [2 4 6 8];

    % These are the coefs for the modified-Blackman-window used in the Versa-Filter:
    aopt =[0.48216433063585  -0.48550251793519   0.03233315142896];

end

aopt
window_opt = win(Nfir,aopt,wtype);
window_opt = window_opt./sum(window_opt);   % normalize window so DC gain is 1

% Plot window and response of window:
figure
subplot(2,1,1)
plot(window_opt), zoom on
axis([0, Nfir, 0, 0.02])
[H,f] = freqz(window_opt,[1], 8*1024, fs);
subplot(2,1,2)
plot(f,20*log10(abs(H)))
title('Magnitude Response of Optimal Window')
xlabel('Frequency (KHz))')
ylabel('Magnitude Response (dB)')
grid on
zoom on
axis([0, fs/2, -100,10])


%*************************************************************************:
% Generate filt.h header file for the filter module: 
% Save FIR window parameters:
[fid, measage] = fopen('c:\work\sps\filter\filtsoft\filt.h','wt');
fprintf(fid, '/* This file was automaticaly generated by filt.m */\n');

%fprintf(fid, '/* and is used to transfer the window parameters to filt.c */\n');
%fprintf(fid, ' \n');
%fprintf(fid, 'const float a_optimal[]={\n');
%for i=1:length(aopt)
%   fprintf(fid, '    %20.10e,\n', aopt(i));
%end
%fprintf(fid, '};\n');

% Define default calibration constants for the Versa-Filter:
log2d4 = log10(2)/4;
in_cal_levels = (0.815/8)*(10.^(log2d4*(0:15)));
out_cal = 1.69*7.1*(10.^(-log2d4*(0:31)));

fprintf(fid, 'float in_cal_levels[]={\n');
for i=1:16
   fprintf(fid, '    %20.10e,\n', in_cal_levels(i));
end
fprintf(fid, '};\n');

fprintf(fid, 'float out_cal[]={\n');
for i=1:32
   fprintf(fid, '    %20.10e,\n', out_cal(i));
end
fprintf(fid, '};\n');

fclose(fid);


% error('end for now')
junk = input('Hit Enter to continue...', 's');

%***************************** DSP ***************************************:
% Plot some sample responses:
M = Nfir - 1;       % Filter length - 1
% specify filter: G =       1 - lowpass,  fc, 0
%                           2 - highpass, fc, 0
%                           3 - bandpass, f1, f2
%                           4 - highpass, f2, f2

G = [];
% fc = linspace(0,fs/2,40)';
fc = linspace(0,fs/2,25)';
fc = [1 1 2 5 10 20 20]';
fc(end) = [];       % delete last element
fc(1) = [];     % delete first element
fwidth = linspace(0,fs/2,26)';
fwidth = [2 2 4 8 10 10]';
fwidth(end) = [];   % delete last element
fwidth(1) = [];     % delete first element
f1 = fs/4 - fwidth/2;
f2 = fs/4 + fwidth/2;
G = [G; [ones(size(fc)), fc, zeros(size(fc))]];
G = [G; [2*ones(size(fc)), fc, zeros(size(fc))]];
G = [G; [3*ones(size(f1)), f1, f2]];
G = [G; [4*ones(size(f1)), f1, f2]];

[mg, ng] = size(G);
maxh = zeros(mg,1);
centerh = zeros(mg,1);
% figure, hold on
for fidx = 1:mg
   if(G(fidx,1)==1)
      g = [1, 0, 0];
        f = [G(fidx,2), fs/2];
   elseif(G(fidx,1)==2)
      g = [0, 1, 0];
        f = [G(fidx,2), fs/2];
   elseif(G(fidx,1)==3)
      g = [0, 1, 0, 0];
        f = [G(fidx,2:3), fs/2];
   elseif(G(fidx,1)==4)
      g = [1, 0, 1, 0];
        f = [G(fidx,2:3), fs/2];
   end
   % design ideal filter:
    Nbands = length(f); % Number of bands
    hrect = zeros(Nfir,1);
    for n = 0:M
        ssum = 0;
    for k = 1:Nbands
        t1 = pi*(n - M/2);
        if(t1==0)
          sincx = (2/fs)*f(k);
        else
          sincx = sin((2/fs)*f(k)*t1)/t1;
        end
       ssum = ssum + (g(k) - g(k+1))*sincx;
       end
       hrect(n+1) = ssum;
    end

   h = hrect.*window;       % Weight ideal filter
   maxh(fidx) = max(abs(h));
   centerh(fidx) = h((Nfir+1)/2);
   
   % error(' ')
   
   % Perform coef. quantization:
   nbits = 16;
   h = (2^-nbits)*fix((2^nbits)*h);
   
   
   % Plot results
   plotr = 1;
   if(plotr)
        % figure, plot(h)
       if(0)
       [H,f] = freqz(hrect,[1], 1*1024, fs);
        figure
        plot(f,20*log10(abs(H)))
        title('Magnitude Response of Rectangular Windowed filter')
        xlabel('Frequency (KHz))')
        ylabel('Magnitude Response (dB)')
        grid on
        zoom on
        axis([0, fs/2, -100,10])
        %   print c:\work\sps\filter\filtsoft\ideal.eps -deps -tiff
       end
      
       if(0)
      figure
        plot(h)
        title('Impulse Response')
        xlabel('Sample')
        grid on
      zoom on
      end

       [H,f] = freqz(h,[1], 1*1024, fs);
        figure
        plot(f,20*log10(abs(H)))
        title('Magnitude Response of FIR Filter')
        xlabel('Frequency (KHz))')
        ylabel('Magnitude Response (dB)')
        grid on
        zoom on
        % axis([0, fs/2, -100,10])
        axis([0, 25, -100,10])
      % print c:\work\sps\filter\filtsoft\ideal.eps -deps -tiff
      % print -dbitmap      % paste figure image
   end

end
err = sum(abs(maxh - centerh))
centerh
maxcenterh = max(centerh)
mincenterh = min(centerh)
